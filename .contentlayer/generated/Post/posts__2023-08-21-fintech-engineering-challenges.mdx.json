{
  "title": "Fintech Engineering Challenges",
  "excerpt": "Having worked in financial services for most of my career I want to share some the software engineering challenges that are associated with tracking and moving money digitally. Most of these lessons have been learned the hard way. Hopefully they will be useful to anyone moving into the fintech space.",
  "coverImage": "/assets/blog/img/fintech.jpg",
  "date": "2023-08-21T00:00:00.000Z",
  "published": true,
  "author": {
    "name": "Dan Stroot",
    "picture": "/assets/blog/authors/dan.jpeg",
    "type": "Author",
    "_raw": {}
  },
  "ogImage": {
    "url": "/assets/blog/img/fintech.jpg",
    "type": "OGImage",
    "_raw": {}
  },
  "seoURL": null,
  "body": {
    "raw": "\nHaving worked in financial services/fintech for most of my career I want to share some the software engineering challenges that are associated with tracking and moving money digitally. Most of these lessons have been learned the hard way. Hopefully they will be useful to anyone moving into the fintech space.\n\nNote: I am intentionally ignoring the broad topic of \"security\" because that alone is a much longer article - however some of the items below are strong controls and help with security. Good design patterns help with both challenges.\n\n## Table of Contents\n\n<div className=\"px-2 w-full md:w-2/3 xl:w-1/2\">\n\n| No. | Section                                  |\n| --- | ---------------------------------------- |\n| 1   | [Significant Digits/Rounding](#1)        |\n| 2   | [Ledgers, Accounts and Transactions](#2) |\n| 3   | [Reporting Periods](#reporting-periods)  |\n| 4   | [Reconciliation](#4)                     |\n| 5   | [Transaction States](#5)                 |\n| 6   | [Immutability](#6)                       |\n| 7   | [Currency Codes](#7)                     |\n| 8   | [Time/Timestamps](#8)                    |\n| 9   | [Retry Logic](#9)                        |\n| 10  | [Architecture](#10)                      |\n| 11  | [Identity Management](#11)               |\n| 11  | [Testing and Release Management](#12)    |\n| 12  | [Application Monitoring](#13)            |\n\n</div>\n\n## <a name='1'></a>Significant Digits/Rounding\n\nThis is so critical that I once wrote a whitepaper on this topic alone. When floating point numbers (numbers that have a decimal point) are represented in binary, they lose precision. For example, ten cents (0.10) in binary is a repeating binary number that goes on forever like this:\n\n<div className=\"hidden break-words text-sm\">\n  0.0001100110011001100110011001100110011001100110011...\n</div>\n\nIf you use floating point numbers to represent currency, computers will have to round them, and the rounding errors will add up and become noticeable, even substantial. Start with $10.00 USD and divide it equally into three payments, rounded to two decimals - you will have three $3.33 transactions. Add them back up and you have $9.99, not $10.00. You made a penny disappear into thin air (0.1% of the total value!).\n\nCurrency math is more closely related to integer math than it is to floating point math. Rounding errors on addition and subtraction are not allowed and division/multiplication should never create more accuracy than the original values. If money needs to be divided, and division isn&apos;t even, rounding should be apportioned according to well-understood business rules. In other words, in the example above you should end up with three transactions, two for $3.33 and one for $3.34. This is best accomplished with a well-tested [currency math library](https://metacpan.org/pod/Math::Currency) in your chosen language. Do not attempt to write this yourself.\n\nNotes:\n\n- How you _store_ monetary values is a key decision and has to align with your currency math library. For accounting applications it's very common to store values as integers (e.g., use `BigInt`) in the database. For example, take the amount of the transaction (let's suppose $100.23) and multiply by 100, 1000, 10000, etc. to get the accuracy you need. If you only need to store USD just multiply by 100 (but note many currencies have more than two digits after the decimal). In the example, you would store the integer 10023. You'll save space in the database and comparing two integers doesn't have the gotcha's of comparing two floats. Many recommend `Decimal(19,4)`. Some relational databases, such as Postgres, support a `Money` type but then you are wedded to that specific database.\n\n- When using JSON to pass monetary quantities (e.g., from the frontend to the backend) use integers like [Stripe](https://stripe.com/docs/api/prices/create#create_price-unit_amount) and [Square](https://developer.squareup.com/reference/square/objects/Money). Otherwise, consider putting the values in strings - you never know what the serializers and deserializers across languages will do to your numbers.\n\n- When processing currency values you need to strip currency formatting and standardize the decimal. Great Britain and the United States are two of the few places in the world that use a period to indicate the decimal place. Many other countries use a comma instead - and three digits after the decimal instead of two. The decimal separator is also called the _radix character_. Likewise, while the U.K. and U.S. use a comma to separate groups of thousands, many other countries use a period, and some countries separate thousands with a thin space. You need libraries that can encode and decode human-readable values for each currency. You also need to be able to convert currency codes to currency symbols.\n\n- This isn't specific to currency but sometimes what you think is a \"number\" isn't. You often need to use strings. If you need to store a bank account number like “01234567789” it will have the leading zero stripped if you use a numeric type.\n\n## <a name='2'></a>Ledgers, Accounts and Transactions\n\nThe core concept of most financial systems is a current value which is changed via \"transactions\". We can model this as an \"account\" table and a \"transaction\" table. When a new account is created it has a value of zero. The account value is then updated via transactions (events) and reflects the current state. The transactions are stored for the lifetime as the account, along with precise timestamps so we know the sequence they were applied.\n\nMartin Fowler calls this pattern [Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html):\n\n> The fundamental idea of Event Sourcing is that of ensuring every change to the state of an application is captured in an event object, and that these event objects are themselves stored in the sequence they were applied for the same lifetime as the application state itself.\n>\n> <cite>&mdash; Martin Fowler, Event Sourcing</cite>\n\nWe should always be able to start at zero, re-apply the transactions in order, and arrive at the same current account state. However, what happens we have millions of accounts and billions of transactions? Can we easily and quickly validate our account values? How can we spot errors?\n\nThis is where **double entry accounting** comes into play. Double-entry accounting originated in the 13th century in Italy to ensure the accuracy of banking and financial records. In a double-entry system, the amounts recorded as debits _must always be equal_ to the amounts recorded as credits.\n\n“Use a double-entry ledger” is probably the most valuable advice I could have sent myself prior to getting into fintech because it allows you to _reconcile all your data all the time_.\n\nIn fact, the term \"balance\" comes from double entry accounting - credits must always balance with debits. Thus, every transaction is _balanced_ – it sums to zero. For example, if we sell a $100 widget but haven't been paid yet, we are owed $100, and we have $100 in revenue:\n\n| Ledger Account      | Debit       | Credit      |\n| ------------------- | ----------- | ----------- |\n| accounts_receivable | $100.00     | $0          |\n| revenue_general     | $0          | $100.00     |\n| **Balance**         | **$100.00** | **$100.00** |\n\nTo understand this further let's introduce some terms:\n\n- **Ledger**: A ledger contains accounts and journal (bookkeeping) entries. Every business has one ledger for itself internally. You can also have external ledgers. A bank account is an example of an external ledger.\n\n- **Account**: Ledger accounts categorize the money flowing through the ledger. It is modelled like a tree, with the topmost levels pointing to the balance sheet or profit-loss statement. The second level points to items on the reports. The lower levels are customizable. Examples of common ledger accounts are revenue, accounts receivable, and accounts payable.\n\n- **Journal entry**: this is a single record in the ledger, comparable to a row in a table. It reflects the actual money movement between ledger accounts. This is what we would consider a transaction, or Martin Fowler would call an \"event\".\n\n- **Credits and Debits**: A debit is an entry that is created to indicate either an increase in assets or a decrease in liabilities on a business&apos;s balance sheet. Credits, on the other hand, work in the opposite way - they are mirrors of one another.\n\nIf we are correctly handling transactions via a ledger, we can make sure we are **always in balance**. This is a critical control.\n\n## Reporting Periods\n\nWhen reporting financial results, we have the concept of a period \"close\". For example, in an accounting system there are monthly, quarterly, and annual closes. The goal is that financial reporting should be immutable and idempotent: Close your periods and generate reports for them, and if/when you regenerate the report it must be identical.\n\nOnce a period is closed new transactions cannot affect it - it should be effectively immutable after being closed, except we must handle the edge case of re-opening periods.\n\nIf an \"as of\" (late) transaction arrives for a date/time in a closed period, the period may be re-opened and closed again after the transaction is posted. This can be quite complex as it also requires subsequent transactions to be reversed and re-applied, plus it requires restating the period results, and requires new financial reports to be issued. This is typically done for material transactions only.\n\nFor non-material transactions, the \"as-of\" transaction is posted to the first moment of the current open period instead. In this example the transaction date/time and posting date/time will be different. The transaction date could be September 23rd but posted on October 1st (the first day of the open period.) This also requires any subsequent transactions to be reversed and re-applied.\n\n## <a name='4'></a> Reconciliation\n\n> Reconciliation: A game designed to frustrate the player.\n\nReconciliation is a business process which arises almost entirely because of a lack of structured data and controls in the pipelines that convey money between businesses or people. Because of this, to a greater or lesser degree worldwide, many people must spend a great deal of time every month reconciling incoming payments to invoices or other money movement.\n\nBecause of technological and organizational barriers, the people who do this work (in Accounts Payable, or Operations, or any other seat at the company) often do not have direct visibility into the customer relationships or the full transaction details which gave rise to the invoice, or payment. Money movement is today, after all, just a message between parties related to some type of contract or event. Reconciliation is a business process which arises almost entirely because of a lack of structured data in the pipelines that convey money between businesses.\n\nFor the last several hundred years, these have followed a very well-understood dance. A deal is struck. The exact amount of compensation is decided upon and memorialized by the sender in an invoice. The purchaser receives the invoice, reads it, then wraps money around a metaphorical brick and throws it through a metaphorical window. Someone on the other side of the window then applies forensic science to the question of what caused this particular brick to arrive.\n\nHumans should not be involved in performing reconciliation. They should only be involved in investigating reconciliation issues/errors. My advice is design and **build automated reconciliation into your system from the start**.\n\nThe implications are straightforward: this lowers the total cost of payments by eliminating human effort, which is expensive, and human errors, which are expensive and numerous. An underappreciated consequence is that freeing people from drudgery gives them the ability to do more important, meaningful work. However, reconciliation is complicated by the many states that financial transactions may be in.\n\n## <a name='5'></a>Transaction States\n\nFinancial transactions have many different states. For example, credit card payment states can be authorized, cleared, voided, returned, declined, etc. It can be tempting to just go ahead an update the state on the transaction record. **Don't do that!** Instead, each state change should have its own immutable record, tracking transaction state changes over time.\n\nYou will need transaction state auditability. Auditors looking at a financial system need to trust that every entry in the ledger was made at a specific time and has not been manipulated in any way. “Updating transactions” would be better phrased to an architect as “use an append-only log / event architecture”. Also, it is very beneficial to design and build your transaction state libraries around a \"state machine\" that enforces the business rules of state changes.\n\nBusiness rules are a pit of alligators, but some types of logical validation should be built into your transaction posting logic. If you sell widgets that range from $10.00 to $1,000 USD, should you expect to see a sales transaction for $10 million dollars? Or, one for a penny? At the very least these transactions should be flagged for review.\n\nYou should build data quality rules on top of your data storage. Data quality rules typically fall into one of six dimensions: accuracy, completeness, consistency, timeliness, validity, and uniqueness. Validity rules such as \"can't be null\", \"can't be less than zero\", and \"must be in this range\" can highlight suspect data quickly.\n\n## <a name='6'></a>Immutability\n\nI have mentioned immutable data like transactions and transaction state changes several times now. There are other key benefits to having data be immutable - as an example, ransomware cannot corrupt or encrypt immutable data. Also, immutable data can be optimized for \"write once, read many\" access so it can be more performant.\n\nThis also helps with auditability, information security, and controls. Auditors, CISO's and regulators love immutable data.\n\n## <a name='7'></a>Currency Codes\n\n**Never** record an amount without its associated currency code. Use [ISO standard codes](https://www.iso.org/iso-4217-currency-codes.html). For example, the Swiss franc is represented by CHF – the CH being the code for Switzerland in the ISO 3166 code and F for franc.\n\nDon't be tempted to use currency symbols - they not unique. The Australian dollar, Mexican Peso, Singapore Dollar, and US Dollar all use \"$\". Trust me - use ISO standard currency codes.\n\nAll amounts/values need a corresponding currency code, _everywhere_. In addition, transactions will also need accurate timestamps for many reasons (e.g., to find the most accurate exchange rate).\n\n## <a name='8'></a>Time/Timestamps\n\n**Never** record a transaction without an accurate timestamp. Timestamps and time synchronization are incredibly important in fintech applications for several reasons:\n\n1. _Transaction Ordering:_ Financial transactions need to be processed in the order they were initiated. This is especially crucial in high-frequency trading where trades are often made in milliseconds or microseconds. A small difference in timing could potentially lead to substantial financial gains or losses. Therefore, accurate time synchronization ensures order in the execution of these transactions.\n\n2. _Security:_ Accurate timekeeping helps in maintaining security. For instance, time-based one-time passwords (TOTPs) are widely used in two-factor authentication systems. These passwords are valid only for a short period of time and rely on synchronized clocks on the server and client side.\n\n3. _Audit Trails and Dispute Resolution:_ Timestamping transactions can help create a precise audit trail, which is critical for detecting and investigating fraudulent activities. In case of any dispute, a detailed and accurate transaction history backed by synchronized time can help resolve the issue.\n\n4. _Distributed Processing:_ fintech systems must scale, and in order to scale and maintain reliability they are architected as distributed systems. In distributed systems, time synchronization is important to ensure data consistency. Many financial systems are distributed over different geographical locations, and transactions need to be coordinated between these systems in an orderly fashion. This requires all servers to have their clocks synchronized.\n\nThink of \"currency\" as three seperate components: (_currency code, decimal amount, and timestamp_).\n\nOther considerations:\n\n1. Use TIMESTAMPTZ. Always. The timestamptz datatype is a time zone-aware date and time data type. Furthermore, even for “date fields” consider using a timestamptz. Every date implicitly exists in a timezone, and if you ignore that you&apos;ll get bitten later.\n2. When you&apos;re using JSON to pass around datetime data, Use ISO8601 date and time with offset info, **always**. E.g., \"transaction_timestamp\": \"2023‐06‐28T15:55:22.511Z\".\n3. Use UTC everywhere, even when you find you can't use it _everywhere_.\n4. Another important one to think about is bitemporality. “Created at” vs “effective at”. Not obvious at first, and you&apos;ll need to build it in. Fowler has a good overview [here](https://martinfowler.com/eaaDev/timeNarrative.html).\n\n## <a name='9'></a>Retry Logic\n\nThere are many places in fintech where we want \"exactly once\" transaction processing. Consider API calls: what if we were designing an API endpoint to charge a customer money; accidentally calling it twice would lead to the customer being double charged.\n\nThis is where idempotency keys come into play. When performing an API request, or a transaction, the client generates a unique ID to identify just that operation and sends it up to the server along with the normal payload. The server receives the ID and correlates it with the state of the request on its end. If the client notices a failure, it retries the request _with the same ID_, and from there it’s up to the server to figure out what to do with it.\n\n- On retrying a connection failure, on the second request the server will see the ID for the first time and process it normally.\n- On a failure midway through an operation, the exact behavior is heavily dependent on implementation, but if the previous operation was successfully rolled back by way of an ACID database, it’ll be safe to retry it.\n- On a response failure (i.e., the operation executed successfully, but the client couldn’t get the result), the server simply replies with a cached result of the successful operation.\n\n“Be careful with retry” should be more strictly “use idempotent operations” and link to the canonical Stripe article on [idempotency](https://stripe.com/blog/idempotency).\n\n## <a name='10'></a>Architecture\n\nA well-designed architecture not only ensures optimal performance and scalability but also addresses critical concerns of security, compliance, and user experience. This article provides some clear, high-level advice.\n\n1. **Study any and all code** you can get your hands on first. For example, a great open source banking core having many of the strengths listed is [Apache Fineract](https://github.com/apache/fineract/). Also check out the links in the References section below.\n\n2. **Model your processes**. One of the best to keep complexity in check is to model processes as state machines (with the state itself being persisted to DB). State machines can be formally tested. By modelling your systems, you will learn what the important failure modes are and you will get better at designing systems that are resilient and efficient.\n\n3. **Use formal methods.** Harnessing the capabilities of formal software architecture design methodologies offers a structured approach to conceptualizing, designing, and implementing complex financial systems, ensuring robustness, reliability, and adherence to industry standards. Complex fintech projects involve multidisciplinary teams. Formal architectures provide a shared language and understanding, enhancing collaboration among developers, architects, domain experts, and business stakeholders. Incorporating formal architecture or design methods into fintech endeavors is an investment in long-term success.\n\n4. **Use proven design patterns**. Queues, retries, event sourcing, payment state handling -- we live in a concurrent world with network failures and our system will need to gracefully handle outages. Vendors will have errors and outages too. Use design patterns that help with robustness and reliability.\n\n   Card payment systems are basically unreliable peer-to-peer messaging systems. Be prepared for a lot of complexity. Using an event-sourcing architecture is useful here for that \"auditing\" requirement and for debugging transaction state when the network sends you messages in error, out of order, or they forget to retry themselves when they promised to, when merchants send bad data, when POS systems do weird things, etc. Your partners **will** send you bad data - be prepared to validate all input data thoroughly and have strategies in place for when it's wrong.\n\n5. **Use well designed, tested, and trusted componentry**. The libraries and SDKs you will need to use will become a large, critical part of your overall technology stack and some of these decisions will be very difficult to unwind if they don't work out. Knowing how to wrap and use third party libraries for things like DOCv step up, remote deposit capture, and security features is table stakes. If your stack choices make this challenging you're going to have a hard time for a long time.\n\n6. **Formalize your testing strategy and code coverage epectations**. It's nearly impossible to be successful with lightweight, informal testing strategies employed by busy software teams. Yes, you will be tempted to \"move fast\" and use prototypes, etc. But if you don't build in robust automated testing from the start along with methods of managing test data you will have a hard time.\n\nOther considerations:\n\n- Maker-checker is a powerful concept. Embrace it to the fullest across your system.\n- You will be dealing with all sorts of non-standardized financial integrations. A lot. Think [adapter pattern](https://refactoring.guru/design-patterns/adapter/typescript/example) as early as possible.\n- You will likely be answering to multiple regulatory agencies. Create boundaries between them within your system and reduce the surface of compliance as much as possible.\n- Be paranoid about race conditions / serialization anomalies.\n- Use immutable storage where possible (this also protects from ransomware).\n\n## <a name='11'></a>Identity Management\n\nFinancial systems attract fraud. One of the best ways to combat fraud is having robust ways to determine that someone is who they claim to be, and that they are a human. Identity management is the bedrock upon which the entire financial ecosystem is built, offering protection against fraud and ensuring the overall robustness of the ecosystem. Identity theft, account takeovers, and fraudulent transactions are just a few examples of the threats that financial institutions face. Identity management acts as a bulwark against these threats.\n\nThe financial ecosystem is a complex network of institutions, customers, partners, and regulators. The integrity of this ecosystem relies heavily on the accurate identification and verification of all participants. Identity management plays a crucial role in maintaining the trust and credibility that underpin financial transactions. By establishing a reliable and secure means of confirming identities, financial institutions can confidently interact with each other, customers can trust the services they receive, and regulators can ensure compliance with relevant laws and regulations.\n\nThis is where a partner like [Socure](https://www.socure.com/) can help - this is very hard to get right and takes lots of design and build time to get right. My advice is not to do this yourself.\n\n## <a name=\"12\"></a>Testing and Release Management\n\nDeciding how to configure environments — dev, test, prod, etc. — and how to ensure they are running properly can be rough in any organization. In fintech, when **real money** moves on prod, and core functionality depends on numerous third-party integrations, it is very challenging. This article is not the place to explain how to do it, but there are three common mistakes to avoid.\n\n1. Many companies have a confusing or poorly documented path from test to production for third party integrators. Make this path clear, and while you&apos;re at it, do a risk analysis on whether it could ever be possible for a third party to connect to the wrong environment without catching their own mistake.\n\n2. Plan for every important configuration of your production environment to be testable. Testability might require multiple test merchants and test accounts that move real money. You never know when you need to double check that the plumbing is working. Face it: [You Test in Prod](https://increment.com/testing/i-test-in-production/).\n\n3. An often-overlooked requirement is to be able to ensure that the production environment is doing error handling properly. The thing about production systems is that they&apos;re not supposed to have errors, so you can&apos;t see how they perform under error conditions unless you can force errors to happen.\n\n## <a name='13'></a>Application Monitoring\n\nYour application will need a full suite of application metrics that need to be defined **up front** and engineered into the application. Deploying to a public cloud like AWS means that some infrastructure monitoring can be added quickly and almost as an afterthought, but _application_ monitoring cannot.\n\nOn day one of your launch, the CEO will want to know things like how many transactions are being processed and what their total dollar amount is. Another thing that tends to happen early in the life of a fintech is that there will be a drop-off between signups and usage, and someone on the product team will start asking if users are experiencing errors. Be ready with good application monitoring to be able to answer these kinds of questions.\n\nWhat metrics signal fraud attempts? From day one you will have to be vigilant about fraud patterns in your application. Make sure you monitoring on user activity for the inevitable questions that will be coming your way.\n\n### References\n\n- [Double-entry accounting for software engineers](https://www.balanced.software/double-entry-bookkeeping-for-programmers/)\n- [Storing Money and Float Precision](https://lashewi.medium.com/storing-currency-values-and-float-precision-99029c1e8b71)\n- [Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)\n- [Decimal and Thousands Separators](https://docs.oracle.com/cd/E19455-01/806-0169/overview-9/index.html)\n- [Books, an immutable double-entry accounting database service](https://developer.squareup.com/blog/books-an-immutable-double-entry-accounting-database-service/)\n- [Double-entry Bookkeeping for Programmers](https://dev.to/kallmanation/double-entry-bookkeeping-for-programmers-3ok9)\n- [An Engineer's Guide to Double-Entry Bookkeeping](https://anvil.works/blog/double-entry-accounting-for-engineers)\n- [Things I Wish I Knew Before Building a Ledger](https://www.andriosrobert.com/p/things-i-wish-i-knew-before-building)\n- [Twisp - The core accounting engine to power any financial product](https://www.twisp.com)\n- [An Elegant DB Schema for Double-Entry Accounting](https://blog.journalize.io/posts/an-elegant-db-schema-for-double-entry-accounting/)\n- [Uber Ledger on DynamoDB and S3](https://www.youtube.com/watch?v=iN6mhI5hFt4&t=45s)\n- [Reconciliation: A game designed to frustrate the player](https://www.bitsaboutmoney.com/archive/a-game-that-intentionally-frustrates-the-player/)\n",
    "code": "var Component=(()=>{var h=Object.create;var r=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var y=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports),f=(n,t)=>{for(var i in t)r(n,i,{get:t[i],enumerable:!0})},s=(n,t,i,o)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let a of m(t))!g.call(n,a)&&a!==i&&r(n,a,{get:()=>t[a],enumerable:!(o=u(t,a))||o.enumerable});return n};var b=(n,t,i)=>(i=n!=null?h(p(n)):{},s(t||!n||!n.__esModule?r(i,\"default\",{value:n,enumerable:!0}):i,n)),w=n=>s(r({},\"__esModule\",{value:!0}),n);var c=y((S,l)=>{l.exports=_jsx_runtime});var I={};f(I,{default:()=>T,frontmatter:()=>v});var e=b(c()),v={title:\"Fintech Engineering Challenges\",excerpt:\"Having worked in financial services for most of my career I want to share some the software engineering challenges that are associated with tracking and moving money digitally. Most of these lessons have been learned the hard way. Hopefully they will be useful to anyone moving into the fintech space.\",coverImage:\"/assets/blog/img/fintech.jpg\",date:\"2023-08-21\",published:!0,author:{name:\"Dan Stroot\",picture:\"/assets/blog/authors/dan.jpeg\"},ogImage:{url:\"/assets/blog/img/fintech.jpg\"},seoURL:null};function d(n){let t=Object.assign({p:\"p\",h2:\"h2\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",a:\"a\",ul:\"ul\",li:\"li\",em:\"em\",code:\"code\",blockquote:\"blockquote\",strong:\"strong\",ol:\"ol\",h3:\"h3\"},n.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(t.p,{children:\"Having worked in financial services/fintech for most of my career I want to share some the software engineering challenges that are associated with tracking and moving money digitally. Most of these lessons have been learned the hard way. Hopefully they will be useful to anyone moving into the fintech space.\"}),`\n`,(0,e.jsx)(t.p,{children:'Note: I am intentionally ignoring the broad topic of \"security\" because that alone is a much longer article - however some of the items below are strong controls and help with security. Good design patterns help with both challenges.'}),`\n`,(0,e.jsx)(t.h2,{id:\"table-of-contents\",children:\"Table of Contents\"}),`\n`,(0,e.jsx)(\"div\",{className:\"px-2 w-full md:w-2/3 xl:w-1/2\",children:(0,e.jsxs)(t.table,{children:[(0,e.jsx)(t.thead,{children:(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.th,{children:\"No.\"}),(0,e.jsx)(t.th,{children:\"Section\"})]})}),(0,e.jsxs)(t.tbody,{children:[(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"1\"}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.a,{href:\"#1\",children:\"Significant Digits/Rounding\"})})]}),(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"2\"}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.a,{href:\"#2\",children:\"Ledgers, Accounts and Transactions\"})})]}),(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"3\"}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.a,{href:\"#reporting-periods\",children:\"Reporting Periods\"})})]}),(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"4\"}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.a,{href:\"#4\",children:\"Reconciliation\"})})]}),(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"5\"}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.a,{href:\"#5\",children:\"Transaction States\"})})]}),(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"6\"}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.a,{href:\"#6\",children:\"Immutability\"})})]}),(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"7\"}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.a,{href:\"#7\",children:\"Currency Codes\"})})]}),(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"8\"}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.a,{href:\"#8\",children:\"Time/Timestamps\"})})]}),(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"9\"}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.a,{href:\"#9\",children:\"Retry Logic\"})})]}),(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"10\"}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.a,{href:\"#10\",children:\"Architecture\"})})]}),(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"11\"}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.a,{href:\"#11\",children:\"Identity Management\"})})]}),(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"11\"}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.a,{href:\"#12\",children:\"Testing and Release Management\"})})]}),(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"12\"}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.a,{href:\"#13\",children:\"Application Monitoring\"})})]})]})]})}),`\n`,(0,e.jsxs)(t.h2,{id:\"significant-digitsrounding\",children:[(0,e.jsx)(\"a\",{name:\"1\"}),\"Significant Digits/Rounding\"]}),`\n`,(0,e.jsx)(t.p,{children:\"This is so critical that I once wrote a whitepaper on this topic alone. When floating point numbers (numbers that have a decimal point) are represented in binary, they lose precision. For example, ten cents (0.10) in binary is a repeating binary number that goes on forever like this:\"}),`\n`,(0,e.jsx)(\"div\",{className:\"hidden break-words text-sm\",children:(0,e.jsx)(t.p,{children:\"0.0001100110011001100110011001100110011001100110011...\"})}),`\n`,(0,e.jsx)(t.p,{children:\"If you use floating point numbers to represent currency, computers will have to round them, and the rounding errors will add up and become noticeable, even substantial. Start with $10.00 USD and divide it equally into three payments, rounded to two decimals - you will have three $3.33 transactions. Add them back up and you have $9.99, not $10.00. You made a penny disappear into thin air (0.1% of the total value!).\"}),`\n`,(0,e.jsxs)(t.p,{children:[\"Currency math is more closely related to integer math than it is to floating point math. Rounding errors on addition and subtraction are not allowed and division/multiplication should never create more accuracy than the original values. If money needs to be divided, and division isn't even, rounding should be apportioned according to well-understood business rules. In other words, in the example above you should end up with three transactions, two for $3.33 and one for $3.34. This is best accomplished with a well-tested \",(0,e.jsx)(t.a,{href:\"https://metacpan.org/pod/Math::Currency\",children:\"currency math library\"}),\" in your chosen language. Do not attempt to write this yourself.\"]}),`\n`,(0,e.jsx)(t.p,{children:\"Notes:\"}),`\n`,(0,e.jsxs)(t.ul,{children:[`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[\"How you \",(0,e.jsx)(t.em,{children:\"store\"}),\" monetary values is a key decision and has to align with your currency math library. For accounting applications it's very common to store values as integers (e.g., use \",(0,e.jsx)(t.code,{children:\"BigInt\"}),\") in the database. For example, take the amount of the transaction (let's suppose $100.23) and multiply by 100, 1000, 10000, etc. to get the accuracy you need. If you only need to store USD just multiply by 100 (but note many currencies have more than two digits after the decimal). In the example, you would store the integer 10023. You'll save space in the database and comparing two integers doesn't have the gotcha's of comparing two floats. Many recommend \",(0,e.jsx)(t.code,{children:\"Decimal(19,4)\"}),\". Some relational databases, such as Postgres, support a \",(0,e.jsx)(t.code,{children:\"Money\"}),\" type but then you are wedded to that specific database.\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[\"When using JSON to pass monetary quantities (e.g., from the frontend to the backend) use integers like \",(0,e.jsx)(t.a,{href:\"https://stripe.com/docs/api/prices/create#create_price-unit_amount\",children:\"Stripe\"}),\" and \",(0,e.jsx)(t.a,{href:\"https://developer.squareup.com/reference/square/objects/Money\",children:\"Square\"}),\". Otherwise, consider putting the values in strings - you never know what the serializers and deserializers across languages will do to your numbers.\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[\"When processing currency values you need to strip currency formatting and standardize the decimal. Great Britain and the United States are two of the few places in the world that use a period to indicate the decimal place. Many other countries use a comma instead - and three digits after the decimal instead of two. The decimal separator is also called the \",(0,e.jsx)(t.em,{children:\"radix character\"}),\". Likewise, while the U.K. and U.S. use a comma to separate groups of thousands, many other countries use a period, and some countries separate thousands with a thin space. You need libraries that can encode and decode human-readable values for each currency. You also need to be able to convert currency codes to currency symbols.\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsx)(t.p,{children:`This isn't specific to currency but sometimes what you think is a \"number\" isn't. You often need to use strings. If you need to store a bank account number like \\u201C01234567789\\u201D it will have the leading zero stripped if you use a numeric type.`}),`\n`]}),`\n`]}),`\n`,(0,e.jsxs)(t.h2,{id:\"ledgers-accounts-and-transactions\",children:[(0,e.jsx)(\"a\",{name:\"2\"}),\"Ledgers, Accounts and Transactions\"]}),`\n`,(0,e.jsx)(t.p,{children:'The core concept of most financial systems is a current value which is changed via \"transactions\". We can model this as an \"account\" table and a \"transaction\" table. When a new account is created it has a value of zero. The account value is then updated via transactions (events) and reflects the current state. The transactions are stored for the lifetime as the account, along with precise timestamps so we know the sequence they were applied.'}),`\n`,(0,e.jsxs)(t.p,{children:[\"Martin Fowler calls this pattern \",(0,e.jsx)(t.a,{href:\"https://martinfowler.com/eaaDev/EventSourcing.html\",children:\"Event Sourcing\"}),\":\"]}),`\n`,(0,e.jsxs)(t.blockquote,{children:[`\n`,(0,e.jsx)(t.p,{children:\"The fundamental idea of Event Sourcing is that of ensuring every change to the state of an application is captured in an event object, and that these event objects are themselves stored in the sequence they were applied for the same lifetime as the application state itself.\"}),`\n`,(0,e.jsx)(\"cite\",{children:\"\\u2014 Martin Fowler, Event Sourcing\"}),`\n`]}),`\n`,(0,e.jsx)(t.p,{children:\"We should always be able to start at zero, re-apply the transactions in order, and arrive at the same current account state. However, what happens we have millions of accounts and billions of transactions? Can we easily and quickly validate our account values? How can we spot errors?\"}),`\n`,(0,e.jsxs)(t.p,{children:[\"This is where \",(0,e.jsx)(t.strong,{children:\"double entry accounting\"}),\" comes into play. Double-entry accounting originated in the 13th century in Italy to ensure the accuracy of banking and financial records. In a double-entry system, the amounts recorded as debits \",(0,e.jsx)(t.em,{children:\"must always be equal\"}),\" to the amounts recorded as credits.\"]}),`\n`,(0,e.jsxs)(t.p,{children:[\"\\u201CUse a double-entry ledger\\u201D is probably the most valuable advice I could have sent myself prior to getting into fintech because it allows you to \",(0,e.jsx)(t.em,{children:\"reconcile all your data all the time\"}),\".\"]}),`\n`,(0,e.jsxs)(t.p,{children:['In fact, the term \"balance\" comes from double entry accounting - credits must always balance with debits. Thus, every transaction is ',(0,e.jsx)(t.em,{children:\"balanced\"}),\" \\u2013 it sums to zero. For example, if we sell a $100 widget but haven't been paid yet, we are owed $100, and we have $100 in revenue:\"]}),`\n`,(0,e.jsxs)(t.table,{children:[(0,e.jsx)(t.thead,{children:(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.th,{children:\"Ledger Account\"}),(0,e.jsx)(t.th,{children:\"Debit\"}),(0,e.jsx)(t.th,{children:\"Credit\"})]})}),(0,e.jsxs)(t.tbody,{children:[(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"accounts_receivable\"}),(0,e.jsx)(t.td,{children:\"$100.00\"}),(0,e.jsx)(t.td,{children:\"$0\"})]}),(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:\"revenue_general\"}),(0,e.jsx)(t.td,{children:\"$0\"}),(0,e.jsx)(t.td,{children:\"$100.00\"})]}),(0,e.jsxs)(t.tr,{children:[(0,e.jsx)(t.td,{children:(0,e.jsx)(t.strong,{children:\"Balance\"})}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.strong,{children:\"$100.00\"})}),(0,e.jsx)(t.td,{children:(0,e.jsx)(t.strong,{children:\"$100.00\"})})]})]})]}),`\n`,(0,e.jsx)(t.p,{children:\"To understand this further let's introduce some terms:\"}),`\n`,(0,e.jsxs)(t.ul,{children:[`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:\"Ledger\"}),\": A ledger contains accounts and journal (bookkeeping) entries. Every business has one ledger for itself internally. You can also have external ledgers. A bank account is an example of an external ledger.\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:\"Account\"}),\": Ledger accounts categorize the money flowing through the ledger. It is modelled like a tree, with the topmost levels pointing to the balance sheet or profit-loss statement. The second level points to items on the reports. The lower levels are customizable. Examples of common ledger accounts are revenue, accounts receivable, and accounts payable.\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:\"Journal entry\"}),': this is a single record in the ledger, comparable to a row in a table. It reflects the actual money movement between ledger accounts. This is what we would consider a transaction, or Martin Fowler would call an \"event\".']}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:\"Credits and Debits\"}),\": A debit is an entry that is created to indicate either an increase in assets or a decrease in liabilities on a business's balance sheet. Credits, on the other hand, work in the opposite way - they are mirrors of one another.\"]}),`\n`]}),`\n`]}),`\n`,(0,e.jsxs)(t.p,{children:[\"If we are correctly handling transactions via a ledger, we can make sure we are \",(0,e.jsx)(t.strong,{children:\"always in balance\"}),\". This is a critical control.\"]}),`\n`,(0,e.jsx)(t.h2,{id:\"reporting-periods\",children:\"Reporting Periods\"}),`\n`,(0,e.jsx)(t.p,{children:'When reporting financial results, we have the concept of a period \"close\". For example, in an accounting system there are monthly, quarterly, and annual closes. The goal is that financial reporting should be immutable and idempotent: Close your periods and generate reports for them, and if/when you regenerate the report it must be identical.'}),`\n`,(0,e.jsx)(t.p,{children:\"Once a period is closed new transactions cannot affect it - it should be effectively immutable after being closed, except we must handle the edge case of re-opening periods.\"}),`\n`,(0,e.jsx)(t.p,{children:'If an \"as of\" (late) transaction arrives for a date/time in a closed period, the period may be re-opened and closed again after the transaction is posted. This can be quite complex as it also requires subsequent transactions to be reversed and re-applied, plus it requires restating the period results, and requires new financial reports to be issued. This is typically done for material transactions only.'}),`\n`,(0,e.jsx)(t.p,{children:'For non-material transactions, the \"as-of\" transaction is posted to the first moment of the current open period instead. In this example the transaction date/time and posting date/time will be different. The transaction date could be September 23rd but posted on October 1st (the first day of the open period.) This also requires any subsequent transactions to be reversed and re-applied.'}),`\n`,(0,e.jsxs)(t.h2,{id:\"-reconciliation\",children:[(0,e.jsx)(\"a\",{name:\"4\"}),\" Reconciliation\"]}),`\n`,(0,e.jsxs)(t.blockquote,{children:[`\n`,(0,e.jsx)(t.p,{children:\"Reconciliation: A game designed to frustrate the player.\"}),`\n`]}),`\n`,(0,e.jsx)(t.p,{children:\"Reconciliation is a business process which arises almost entirely because of a lack of structured data and controls in the pipelines that convey money between businesses or people. Because of this, to a greater or lesser degree worldwide, many people must spend a great deal of time every month reconciling incoming payments to invoices or other money movement.\"}),`\n`,(0,e.jsx)(t.p,{children:\"Because of technological and organizational barriers, the people who do this work (in Accounts Payable, or Operations, or any other seat at the company) often do not have direct visibility into the customer relationships or the full transaction details which gave rise to the invoice, or payment. Money movement is today, after all, just a message between parties related to some type of contract or event. Reconciliation is a business process which arises almost entirely because of a lack of structured data in the pipelines that convey money between businesses.\"}),`\n`,(0,e.jsx)(t.p,{children:\"For the last several hundred years, these have followed a very well-understood dance. A deal is struck. The exact amount of compensation is decided upon and memorialized by the sender in an invoice. The purchaser receives the invoice, reads it, then wraps money around a metaphorical brick and throws it through a metaphorical window. Someone on the other side of the window then applies forensic science to the question of what caused this particular brick to arrive.\"}),`\n`,(0,e.jsxs)(t.p,{children:[\"Humans should not be involved in performing reconciliation. They should only be involved in investigating reconciliation issues/errors. My advice is design and \",(0,e.jsx)(t.strong,{children:\"build automated reconciliation into your system from the start\"}),\".\"]}),`\n`,(0,e.jsx)(t.p,{children:\"The implications are straightforward: this lowers the total cost of payments by eliminating human effort, which is expensive, and human errors, which are expensive and numerous. An underappreciated consequence is that freeing people from drudgery gives them the ability to do more important, meaningful work. However, reconciliation is complicated by the many states that financial transactions may be in.\"}),`\n`,(0,e.jsxs)(t.h2,{id:\"transaction-states\",children:[(0,e.jsx)(\"a\",{name:\"5\"}),\"Transaction States\"]}),`\n`,(0,e.jsxs)(t.p,{children:[\"Financial transactions have many different states. For example, credit card payment states can be authorized, cleared, voided, returned, declined, etc. It can be tempting to just go ahead an update the state on the transaction record. \",(0,e.jsx)(t.strong,{children:\"Don't do that!\"}),\" Instead, each state change should have its own immutable record, tracking transaction state changes over time.\"]}),`\n`,(0,e.jsx)(t.p,{children:'You will need transaction state auditability. Auditors looking at a financial system need to trust that every entry in the ledger was made at a specific time and has not been manipulated in any way. \\u201CUpdating transactions\\u201D would be better phrased to an architect as \\u201Cuse an append-only log / event architecture\\u201D. Also, it is very beneficial to design and build your transaction state libraries around a \"state machine\" that enforces the business rules of state changes.'}),`\n`,(0,e.jsx)(t.p,{children:\"Business rules are a pit of alligators, but some types of logical validation should be built into your transaction posting logic. If you sell widgets that range from $10.00 to $1,000 USD, should you expect to see a sales transaction for $10 million dollars? Or, one for a penny? At the very least these transactions should be flagged for review.\"}),`\n`,(0,e.jsx)(t.p,{children:`You should build data quality rules on top of your data storage. Data quality rules typically fall into one of six dimensions: accuracy, completeness, consistency, timeliness, validity, and uniqueness. Validity rules such as \"can't be null\", \"can't be less than zero\", and \"must be in this range\" can highlight suspect data quickly.`}),`\n`,(0,e.jsxs)(t.h2,{id:\"immutability\",children:[(0,e.jsx)(\"a\",{name:\"6\"}),\"Immutability\"]}),`\n`,(0,e.jsx)(t.p,{children:'I have mentioned immutable data like transactions and transaction state changes several times now. There are other key benefits to having data be immutable - as an example, ransomware cannot corrupt or encrypt immutable data. Also, immutable data can be optimized for \"write once, read many\" access so it can be more performant.'}),`\n`,(0,e.jsx)(t.p,{children:\"This also helps with auditability, information security, and controls. Auditors, CISO's and regulators love immutable data.\"}),`\n`,(0,e.jsxs)(t.h2,{id:\"currency-codes\",children:[(0,e.jsx)(\"a\",{name:\"7\"}),\"Currency Codes\"]}),`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:\"Never\"}),\" record an amount without its associated currency code. Use \",(0,e.jsx)(t.a,{href:\"https://www.iso.org/iso-4217-currency-codes.html\",children:\"ISO standard codes\"}),\". For example, the Swiss franc is represented by CHF \\u2013 the CH being the code for Switzerland in the ISO 3166 code and F for franc.\"]}),`\n`,(0,e.jsx)(t.p,{children:`Don't be tempted to use currency symbols - they not unique. The Australian dollar, Mexican Peso, Singapore Dollar, and US Dollar all use \"$\". Trust me - use ISO standard currency codes.`}),`\n`,(0,e.jsxs)(t.p,{children:[\"All amounts/values need a corresponding currency code, \",(0,e.jsx)(t.em,{children:\"everywhere\"}),\". In addition, transactions will also need accurate timestamps for many reasons (e.g., to find the most accurate exchange rate).\"]}),`\n`,(0,e.jsxs)(t.h2,{id:\"timetimestamps\",children:[(0,e.jsx)(\"a\",{name:\"8\"}),\"Time/Timestamps\"]}),`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:\"Never\"}),\" record a transaction without an accurate timestamp. Timestamps and time synchronization are incredibly important in fintech applications for several reasons:\"]}),`\n`,(0,e.jsxs)(t.ol,{children:[`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.em,{children:\"Transaction Ordering:\"}),\" Financial transactions need to be processed in the order they were initiated. This is especially crucial in high-frequency trading where trades are often made in milliseconds or microseconds. A small difference in timing could potentially lead to substantial financial gains or losses. Therefore, accurate time synchronization ensures order in the execution of these transactions.\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.em,{children:\"Security:\"}),\" Accurate timekeeping helps in maintaining security. For instance, time-based one-time passwords (TOTPs) are widely used in two-factor authentication systems. These passwords are valid only for a short period of time and rely on synchronized clocks on the server and client side.\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.em,{children:\"Audit Trails and Dispute Resolution:\"}),\" Timestamping transactions can help create a precise audit trail, which is critical for detecting and investigating fraudulent activities. In case of any dispute, a detailed and accurate transaction history backed by synchronized time can help resolve the issue.\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.em,{children:\"Distributed Processing:\"}),\" fintech systems must scale, and in order to scale and maintain reliability they are architected as distributed systems. In distributed systems, time synchronization is important to ensure data consistency. Many financial systems are distributed over different geographical locations, and transactions need to be coordinated between these systems in an orderly fashion. This requires all servers to have their clocks synchronized.\"]}),`\n`]}),`\n`]}),`\n`,(0,e.jsxs)(t.p,{children:['Think of \"currency\" as three seperate components: (',(0,e.jsx)(t.em,{children:\"currency code, decimal amount, and timestamp\"}),\").\"]}),`\n`,(0,e.jsx)(t.p,{children:\"Other considerations:\"}),`\n`,(0,e.jsxs)(t.ol,{children:[`\n`,(0,e.jsx)(t.li,{children:\"Use TIMESTAMPTZ. Always. The timestamptz datatype is a time zone-aware date and time data type. Furthermore, even for \\u201Cdate fields\\u201D consider using a timestamptz. Every date implicitly exists in a timezone, and if you ignore that you'll get bitten later.\"}),`\n`,(0,e.jsxs)(t.li,{children:[\"When you're using JSON to pass around datetime data, Use ISO8601 date and time with offset info, \",(0,e.jsx)(t.strong,{children:\"always\"}),'. E.g., \"transaction_timestamp\": \"2023\\u201006\\u201028T15:55:22.511Z\".']}),`\n`,(0,e.jsxs)(t.li,{children:[\"Use UTC everywhere, even when you find you can't use it \",(0,e.jsx)(t.em,{children:\"everywhere\"}),\".\"]}),`\n`,(0,e.jsxs)(t.li,{children:[\"Another important one to think about is bitemporality. \\u201CCreated at\\u201D vs \\u201Ceffective at\\u201D. Not obvious at first, and you'll need to build it in. Fowler has a good overview \",(0,e.jsx)(t.a,{href:\"https://martinfowler.com/eaaDev/timeNarrative.html\",children:\"here\"}),\".\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.h2,{id:\"retry-logic\",children:[(0,e.jsx)(\"a\",{name:\"9\"}),\"Retry Logic\"]}),`\n`,(0,e.jsx)(t.p,{children:'There are many places in fintech where we want \"exactly once\" transaction processing. Consider API calls: what if we were designing an API endpoint to charge a customer money; accidentally calling it twice would lead to the customer being double charged.'}),`\n`,(0,e.jsxs)(t.p,{children:[\"This is where idempotency keys come into play. When performing an API request, or a transaction, the client generates a unique ID to identify just that operation and sends it up to the server along with the normal payload. The server receives the ID and correlates it with the state of the request on its end. If the client notices a failure, it retries the request \",(0,e.jsx)(t.em,{children:\"with the same ID\"}),\", and from there it\\u2019s up to the server to figure out what to do with it.\"]}),`\n`,(0,e.jsxs)(t.ul,{children:[`\n`,(0,e.jsx)(t.li,{children:\"On retrying a connection failure, on the second request the server will see the ID for the first time and process it normally.\"}),`\n`,(0,e.jsx)(t.li,{children:\"On a failure midway through an operation, the exact behavior is heavily dependent on implementation, but if the previous operation was successfully rolled back by way of an ACID database, it\\u2019ll be safe to retry it.\"}),`\n`,(0,e.jsx)(t.li,{children:\"On a response failure (i.e., the operation executed successfully, but the client couldn\\u2019t get the result), the server simply replies with a cached result of the successful operation.\"}),`\n`]}),`\n`,(0,e.jsxs)(t.p,{children:[\"\\u201CBe careful with retry\\u201D should be more strictly \\u201Cuse idempotent operations\\u201D and link to the canonical Stripe article on \",(0,e.jsx)(t.a,{href:\"https://stripe.com/blog/idempotency\",children:\"idempotency\"}),\".\"]}),`\n`,(0,e.jsxs)(t.h2,{id:\"architecture\",children:[(0,e.jsx)(\"a\",{name:\"10\"}),\"Architecture\"]}),`\n`,(0,e.jsx)(t.p,{children:\"A well-designed architecture not only ensures optimal performance and scalability but also addresses critical concerns of security, compliance, and user experience. This article provides some clear, high-level advice.\"}),`\n`,(0,e.jsxs)(t.ol,{children:[`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:\"Study any and all code\"}),\" you can get your hands on first. For example, a great open source banking core having many of the strengths listed is \",(0,e.jsx)(t.a,{href:\"https://github.com/apache/fineract/\",children:\"Apache Fineract\"}),\". Also check out the links in the References section below.\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:\"Model your processes\"}),\". One of the best to keep complexity in check is to model processes as state machines (with the state itself being persisted to DB). State machines can be formally tested. By modelling your systems, you will learn what the important failure modes are and you will get better at designing systems that are resilient and efficient.\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:\"Use formal methods.\"}),\" Harnessing the capabilities of formal software architecture design methodologies offers a structured approach to conceptualizing, designing, and implementing complex financial systems, ensuring robustness, reliability, and adherence to industry standards. Complex fintech projects involve multidisciplinary teams. Formal architectures provide a shared language and understanding, enhancing collaboration among developers, architects, domain experts, and business stakeholders. Incorporating formal architecture or design methods into fintech endeavors is an investment in long-term success.\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:\"Use proven design patterns\"}),\". Queues, retries, event sourcing, payment state handling -- we live in a concurrent world with network failures and our system will need to gracefully handle outages. Vendors will have errors and outages too. Use design patterns that help with robustness and reliability.\"]}),`\n`,(0,e.jsxs)(t.p,{children:['Card payment systems are basically unreliable peer-to-peer messaging systems. Be prepared for a lot of complexity. Using an event-sourcing architecture is useful here for that \"auditing\" requirement and for debugging transaction state when the network sends you messages in error, out of order, or they forget to retry themselves when they promised to, when merchants send bad data, when POS systems do weird things, etc. Your partners ',(0,e.jsx)(t.strong,{children:\"will\"}),\" send you bad data - be prepared to validate all input data thoroughly and have strategies in place for when it's wrong.\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:\"Use well designed, tested, and trusted componentry\"}),\". The libraries and SDKs you will need to use will become a large, critical part of your overall technology stack and some of these decisions will be very difficult to unwind if they don't work out. Knowing how to wrap and use third party libraries for things like DOCv step up, remote deposit capture, and security features is table stakes. If your stack choices make this challenging you're going to have a hard time for a long time.\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.strong,{children:\"Formalize your testing strategy and code coverage epectations\"}),`. It's nearly impossible to be successful with lightweight, informal testing strategies employed by busy software teams. Yes, you will be tempted to \"move fast\" and use prototypes, etc. But if you don't build in robust automated testing from the start along with methods of managing test data you will have a hard time.`]}),`\n`]}),`\n`]}),`\n`,(0,e.jsx)(t.p,{children:\"Other considerations:\"}),`\n`,(0,e.jsxs)(t.ul,{children:[`\n`,(0,e.jsx)(t.li,{children:\"Maker-checker is a powerful concept. Embrace it to the fullest across your system.\"}),`\n`,(0,e.jsxs)(t.li,{children:[\"You will be dealing with all sorts of non-standardized financial integrations. A lot. Think \",(0,e.jsx)(t.a,{href:\"https://refactoring.guru/design-patterns/adapter/typescript/example\",children:\"adapter pattern\"}),\" as early as possible.\"]}),`\n`,(0,e.jsx)(t.li,{children:\"You will likely be answering to multiple regulatory agencies. Create boundaries between them within your system and reduce the surface of compliance as much as possible.\"}),`\n`,(0,e.jsx)(t.li,{children:\"Be paranoid about race conditions / serialization anomalies.\"}),`\n`,(0,e.jsx)(t.li,{children:\"Use immutable storage where possible (this also protects from ransomware).\"}),`\n`]}),`\n`,(0,e.jsxs)(t.h2,{id:\"identity-management\",children:[(0,e.jsx)(\"a\",{name:\"11\"}),\"Identity Management\"]}),`\n`,(0,e.jsx)(t.p,{children:\"Financial systems attract fraud. One of the best ways to combat fraud is having robust ways to determine that someone is who they claim to be, and that they are a human. Identity management is the bedrock upon which the entire financial ecosystem is built, offering protection against fraud and ensuring the overall robustness of the ecosystem. Identity theft, account takeovers, and fraudulent transactions are just a few examples of the threats that financial institutions face. Identity management acts as a bulwark against these threats.\"}),`\n`,(0,e.jsx)(t.p,{children:\"The financial ecosystem is a complex network of institutions, customers, partners, and regulators. The integrity of this ecosystem relies heavily on the accurate identification and verification of all participants. Identity management plays a crucial role in maintaining the trust and credibility that underpin financial transactions. By establishing a reliable and secure means of confirming identities, financial institutions can confidently interact with each other, customers can trust the services they receive, and regulators can ensure compliance with relevant laws and regulations.\"}),`\n`,(0,e.jsxs)(t.p,{children:[\"This is where a partner like \",(0,e.jsx)(t.a,{href:\"https://www.socure.com/\",children:\"Socure\"}),\" can help - this is very hard to get right and takes lots of design and build time to get right. My advice is not to do this yourself.\"]}),`\n`,(0,e.jsxs)(t.h2,{id:\"testing-and-release-management\",children:[(0,e.jsx)(\"a\",{name:\"12\"}),\"Testing and Release Management\"]}),`\n`,(0,e.jsxs)(t.p,{children:[\"Deciding how to configure environments \\u2014 dev, test, prod, etc. \\u2014 and how to ensure they are running properly can be rough in any organization. In fintech, when \",(0,e.jsx)(t.strong,{children:\"real money\"}),\" moves on prod, and core functionality depends on numerous third-party integrations, it is very challenging. This article is not the place to explain how to do it, but there are three common mistakes to avoid.\"]}),`\n`,(0,e.jsxs)(t.ol,{children:[`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsx)(t.p,{children:\"Many companies have a confusing or poorly documented path from test to production for third party integrators. Make this path clear, and while you're at it, do a risk analysis on whether it could ever be possible for a third party to connect to the wrong environment without catching their own mistake.\"}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsxs)(t.p,{children:[\"Plan for every important configuration of your production environment to be testable. Testability might require multiple test merchants and test accounts that move real money. You never know when you need to double check that the plumbing is working. Face it: \",(0,e.jsx)(t.a,{href:\"https://increment.com/testing/i-test-in-production/\",children:\"You Test in Prod\"}),\".\"]}),`\n`]}),`\n`,(0,e.jsxs)(t.li,{children:[`\n`,(0,e.jsx)(t.p,{children:\"An often-overlooked requirement is to be able to ensure that the production environment is doing error handling properly. The thing about production systems is that they're not supposed to have errors, so you can't see how they perform under error conditions unless you can force errors to happen.\"}),`\n`]}),`\n`]}),`\n`,(0,e.jsxs)(t.h2,{id:\"application-monitoring\",children:[(0,e.jsx)(\"a\",{name:\"13\"}),\"Application Monitoring\"]}),`\n`,(0,e.jsxs)(t.p,{children:[\"Your application will need a full suite of application metrics that need to be defined \",(0,e.jsx)(t.strong,{children:\"up front\"}),\" and engineered into the application. Deploying to a public cloud like AWS means that some infrastructure monitoring can be added quickly and almost as an afterthought, but \",(0,e.jsx)(t.em,{children:\"application\"}),\" monitoring cannot.\"]}),`\n`,(0,e.jsx)(t.p,{children:\"On day one of your launch, the CEO will want to know things like how many transactions are being processed and what their total dollar amount is. Another thing that tends to happen early in the life of a fintech is that there will be a drop-off between signups and usage, and someone on the product team will start asking if users are experiencing errors. Be ready with good application monitoring to be able to answer these kinds of questions.\"}),`\n`,(0,e.jsx)(t.p,{children:\"What metrics signal fraud attempts? From day one you will have to be vigilant about fraud patterns in your application. Make sure you monitoring on user activity for the inevitable questions that will be coming your way.\"}),`\n`,(0,e.jsx)(t.h3,{id:\"references\",children:\"References\"}),`\n`,(0,e.jsxs)(t.ul,{children:[`\n`,(0,e.jsx)(t.li,{children:(0,e.jsx)(t.a,{href:\"https://www.balanced.software/double-entry-bookkeeping-for-programmers/\",children:\"Double-entry accounting for software engineers\"})}),`\n`,(0,e.jsx)(t.li,{children:(0,e.jsx)(t.a,{href:\"https://lashewi.medium.com/storing-currency-values-and-float-precision-99029c1e8b71\",children:\"Storing Money and Float Precision\"})}),`\n`,(0,e.jsx)(t.li,{children:(0,e.jsx)(t.a,{href:\"https://martinfowler.com/eaaDev/EventSourcing.html\",children:\"Event Sourcing\"})}),`\n`,(0,e.jsx)(t.li,{children:(0,e.jsx)(t.a,{href:\"https://docs.oracle.com/cd/E19455-01/806-0169/overview-9/index.html\",children:\"Decimal and Thousands Separators\"})}),`\n`,(0,e.jsx)(t.li,{children:(0,e.jsx)(t.a,{href:\"https://developer.squareup.com/blog/books-an-immutable-double-entry-accounting-database-service/\",children:\"Books, an immutable double-entry accounting database service\"})}),`\n`,(0,e.jsx)(t.li,{children:(0,e.jsx)(t.a,{href:\"https://dev.to/kallmanation/double-entry-bookkeeping-for-programmers-3ok9\",children:\"Double-entry Bookkeeping for Programmers\"})}),`\n`,(0,e.jsx)(t.li,{children:(0,e.jsx)(t.a,{href:\"https://anvil.works/blog/double-entry-accounting-for-engineers\",children:\"An Engineer's Guide to Double-Entry Bookkeeping\"})}),`\n`,(0,e.jsx)(t.li,{children:(0,e.jsx)(t.a,{href:\"https://www.andriosrobert.com/p/things-i-wish-i-knew-before-building\",children:\"Things I Wish I Knew Before Building a Ledger\"})}),`\n`,(0,e.jsx)(t.li,{children:(0,e.jsx)(t.a,{href:\"https://www.twisp.com\",children:\"Twisp - The core accounting engine to power any financial product\"})}),`\n`,(0,e.jsx)(t.li,{children:(0,e.jsx)(t.a,{href:\"https://blog.journalize.io/posts/an-elegant-db-schema-for-double-entry-accounting/\",children:\"An Elegant DB Schema for Double-Entry Accounting\"})}),`\n`,(0,e.jsx)(t.li,{children:(0,e.jsx)(t.a,{href:\"https://www.youtube.com/watch?v=iN6mhI5hFt4&t=45s\",children:\"Uber Ledger on DynamoDB and S3\"})}),`\n`,(0,e.jsx)(t.li,{children:(0,e.jsx)(t.a,{href:\"https://www.bitsaboutmoney.com/archive/a-game-that-intentionally-frustrates-the-player/\",children:\"Reconciliation: A game designed to frustrate the player\"})}),`\n`]})]})}function k(n={}){let{wrapper:t}=n.components||{};return t?(0,e.jsx)(t,Object.assign({},n,{children:(0,e.jsx)(d,n)})):d(n)}var T=k;return w(I);})();\n;return Component;"
  },
  "_id": "posts/2023-08-21-fintech-engineering-challenges.mdx",
  "_raw": {
    "sourceFilePath": "posts/2023-08-21-fintech-engineering-challenges.mdx",
    "sourceFileName": "2023-08-21-fintech-engineering-challenges.mdx",
    "sourceFileDir": "posts",
    "contentType": "mdx",
    "flattenedPath": "posts/2023-08-21-fintech-engineering-challenges"
  },
  "type": "Post",
  "slug": "/posts/2023-08-21-fintech-engineering-challenges",
  "slugAsParams": "2023-08-21-fintech-engineering-challenges",
  "stats": {
    "text": "21 min read",
    "minutes": 20.645,
    "time": 1238700,
    "words": 4129
  }
}