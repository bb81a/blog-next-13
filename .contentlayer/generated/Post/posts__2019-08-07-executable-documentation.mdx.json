{
  "title": "Executable Documentation",
  "excerpt": "Every team has manual procedures or checklists that they haven’t gotten around to automating yet. Sometimes there are branches and special cases to keep track of as you go. Procedures/checklists are frustrating because they’re focus-intensive yet require very little thought. They demand our full attention, but our attention isn’t rewarded with interesting problems or satisfying solutions – just another checkbox checked.",
  "coverImage": "/assets/blog/img/exec_doc.png",
  "date": "2019-08-07T00:00:00.000Z",
  "published": true,
  "author": {
    "name": "Dan Stroot",
    "picture": "/assets/blog/authors/dan.jpeg",
    "type": "Author",
    "_raw": {}
  },
  "ogImage": {
    "url": "/assets/blog/img/exec_doc.png",
    "type": "OGImage",
    "_raw": {}
  },
  "seoURL": "https://danstroot.com/2019/08/06/executable-documentation/",
  "body": {
    "raw": "\nEvery team has manual procedures or checklists that they haven’t gotten around to automating yet. Sometimes there are branches and special cases to keep track of as you go. Procedures/checklists are frustrating because they’re focus-intensive yet require very little thought. They demand our full attention, but our attention isn’t rewarded with interesting problems or satisfying solutions – just another checkbox checked. Procedures like this are called a **slog**.\n\nSlogs are ripe for automation. We know that a computer could do it better than we can, and with less tendency toward practical drift. However, automating slogs feels like an all-or-nothing proposition. Maybe we could write a script to handle step 2, or step 5, but that wouldn’t really make the procedure any less cumbersome. It would lead to a proliferation of single-purpose scripts with different conventions and expectations, and you’d still have to follow a documented multi-step procedure for using those scripts.\n\nThis **perception of futility** is the problem we really need to solve in order to escape from these manual slogs. Here's an approach that works. It's called \"executable documentation\".\n\nAlmost any slog can be turned into executable documentation. Executable documentation is a script that encodes the instructions of a slog, encapsulating each step in a function. For example we could write the following executable documentation script:\n\n```shell\n#! /bin/sh\n# ------------------------------------------------------------\n# Copyright (c) 2014 Dan Stroot\n# All rights reserved.\n# ------------------------------------------------------------\n# NAME:           example.sh\n# PURPOSE:        example of executable documentation\n# VERSION:  1.0   Initial version\n# ------------------------------------------------------------\nset -e\n\n# Default settings\nPROGNAME=$0\nVER=\"1.0\"\n\nstep_1 () {\n    echo \"Do step 1, press (y, enter) when complete.\"\n    read -r response\n    case $response in\n    [yY])\n        echo \"Step 1 completed.\\n\"\n        ;;\n    *)\n        echo \"Step 1 NOT completed.\\n\"\n        exit 1\n        ;;\n    esac\n}\n\nstep_2 () {\n    echo \"Do step 2, press (y, enter) when complete.\"\n    read -r response\n    case $response in\n    [yY])\n        echo \"Step 2 completed.\\n\"\n        ;;\n    *)\n        echo \"Step 2 NOT completed.\\n\"\n        exit 1\n        ;;\n    esac\n}\n\nstep_3 () {\n    echo \"Do step 3, press (y, enter) when complete.\"\n    read -r response\n    case $response in\n    [yY])\n        echo \"Step 3 completed.\\n\"\n        ;;\n    *)\n        echo \"Step 3 NOT completed.\\n\"\n        exit 1\n        ;;\n    esac\n}\n\nmain() {\n    echo \"Running: ${PROGNAME}, version ${VER}.\\n\"\n    step_1\n    step_2\n    step_3\n    echo \"All Done!\"\n    echo \"Wouldn't it be great if this was automated?\"\n}\n\nmain \"$@\"\n```\n\nNotice this script **doesn’t actually do any of the steps of the procedure**! It feeds the user a step at a time and waits for them to complete each step manually. These scripts will have little logic, and make little use of variables. They can also have a .txt filename to ensure that people understand, that first of all, this is a set of instructions for how to do something, which also just so happens to be a valid shell script.\n\nAt first glance, it might not be obvious that this script provides any value, but the value is immense. First, these scripts actually do something: they allow storing and updating the _state_ of a process. By having these scripts run in a shell rather than in your head, the current state is stored in a machine, not your brain.\n\n- It’s now much less likely that you’ll lose your place and skip a step. This makes it easier to maintain focus on the actual work and power through the slog. You can even exit the script and it will tell you where you stopped.\n\n- Each step of the procedure is now encapsulated in a function, which makes it possible to replace the text in any given step with code that actually performs the action.\n\n- Over time, you’ll develop a library of useful steps, which will make future automation tasks more efficient.\n\n- It will lower the inhibition to automation - each run you can just automate one or two more steps.\n\nExecutable documentation doesn’t initially save your team any manual effort. However, **it lowers the activation energy for automating tasks**, which allows the team to eliminate toil over time.\n\nFor example I have a process to reinstall the operating system on my personal laptop from scratch, based on a checklist. I'd always wanted to automate it but it just seemed like such a daunting task that I never ended up doing it. The frequency of use didn't seem to warrant the effort.\n\nLast time I turned the checklist into a script, telling me what to do at each step. Then, since I was scripting rather writing a document I also implemented the ones that are easy to automate. I planned to automate a few more items each time I ran the checklist, until it's fully automated. A funny thing happened though - after few runs I had autmated a large portion of the steps, and that motivated me to just knock it out and finish. This is the power of executable documentation.\n\nExecutable documentation as concept can be very broad - many producst are based around the idea of complex tasks \"as code\". Products like:\n\n- [AWS Cloudformation](https://aws.amazon.com/cloudformation/)\n- [Hashicorp Terraform](https://www.terraform.io)\n- [Chef](https://www.chef.io/)\n- [Puppet](https://puppet.com)\n- [Ansible](https://www.ansible.com/)\n- [Jupyter](https://jupyter.org)\n\nSo you can take this concept pretty far!\n\n#### Resources\n\n- [Manual work is a bug](https://queue.acm.org/detail.cfm?id=3197520)\n- [Record shell sessions](https://www.youtube.com/watch?v=tweyWNr6X18)\n- [NYT - The Checklist](https://www.newyorker.com/magazine/2007/12/10/the-checklist)\n- [The Simple Genius of Checklists, from B-17 to the Apollo Missions](https://blog.nuclino.com/the-simple-genius-of-checklists-from-b-17-to-the-apollo-missions)\n",
    "code": "var Component=(()=>{var p=Object.create;var o=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),w=(n,e)=>{for(var a in e)o(n,a,{get:e[a],enumerable:!0})},r=(n,e,a,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of u(e))!f.call(n,s)&&s!==a&&o(n,s,{get:()=>e[s],enumerable:!(i=d(e,s))||i.enumerable});return n};var y=(n,e,a)=>(a=n!=null?p(m(n)):{},r(e||!n||!n.__esModule?o(a,\"default\",{value:n,enumerable:!0}):a,n)),b=n=>r(o({},\"__esModule\",{value:!0}),n);var c=g((_,l)=>{l.exports=_jsx_runtime});var N={};w(N,{default:()=>x,frontmatter:()=>k});var t=y(c()),k={title:\"Executable Documentation\",excerpt:\"Every team has manual procedures or checklists that they haven\\u2019t gotten around to automating yet. Sometimes there are branches and special cases to keep track of as you go. Procedures/checklists are frustrating because they\\u2019re focus-intensive yet require very little thought. They demand our full attention, but our attention isn\\u2019t rewarded with interesting problems or satisfying solutions \\u2013 just another checkbox checked.\",coverImage:\"/assets/blog/img/exec_doc.png\",date:\"2019-08-07\",published:!0,author:{name:\"Dan Stroot\",picture:\"/assets/blog/authors/dan.jpeg\"},ogImage:{url:\"/assets/blog/img/exec_doc.png\"},seoURL:\"https://danstroot.com/2019/08/06/executable-documentation/\"};function h(n){let e=Object.assign({p:\"p\",strong:\"strong\",pre:\"pre\",code:\"code\",span:\"span\",em:\"em\",ul:\"ul\",li:\"li\",a:\"a\",h4:\"h4\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Every team has manual procedures or checklists that they haven\\u2019t gotten around to automating yet. Sometimes there are branches and special cases to keep track of as you go. Procedures/checklists are frustrating because they\\u2019re focus-intensive yet require very little thought. They demand our full attention, but our attention isn\\u2019t rewarded with interesting problems or satisfying solutions \\u2013 just another checkbox checked. Procedures like this are called a \",(0,t.jsx)(e.strong,{children:\"slog\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Slogs are ripe for automation. We know that a computer could do it better than we can, and with less tendency toward practical drift. However, automating slogs feels like an all-or-nothing proposition. Maybe we could write a script to handle step 2, or step 5, but that wouldn\\u2019t really make the procedure any less cumbersome. It would lead to a proliferation of single-purpose scripts with different conventions and expectations, and you\\u2019d still have to follow a documented multi-step procedure for using those scripts.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"This \",(0,t.jsx)(e.strong,{children:\"perception of futility\"}),` is the problem we really need to solve in order to escape from these manual slogs. Here's an approach that works. It's called \"executable documentation\".`]}),`\n`,(0,t.jsx)(e.p,{children:\"Almost any slog can be turned into executable documentation. Executable documentation is a script that encodes the instructions of a slog, encapsulating each step in a function. For example we could write the following executable documentation script:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsxs)(e.code,{className:\"hljs language-shell\",children:[(0,t.jsx)(e.span,{className:\"hljs-meta prompt_\",children:\"#\"}),(0,t.jsx)(e.span,{className:\"bash\",children:\"! /bin/sh\"}),`\n`,(0,t.jsx)(e.span,{className:\"hljs-meta prompt_\",children:\"# \"}),(0,t.jsx)(e.span,{className:\"bash\",children:\"------------------------------------------------------------\"}),`\n`,(0,t.jsx)(e.span,{className:\"hljs-meta prompt_\",children:\"# \"}),(0,t.jsx)(e.span,{className:\"bash\",children:\"Copyright (c) 2014 Dan Stroot\"}),`\n`,(0,t.jsx)(e.span,{className:\"hljs-meta prompt_\",children:\"# \"}),(0,t.jsx)(e.span,{className:\"bash\",children:\"All rights reserved.\"}),`\n`,(0,t.jsx)(e.span,{className:\"hljs-meta prompt_\",children:\"# \"}),(0,t.jsx)(e.span,{className:\"bash\",children:\"------------------------------------------------------------\"}),`\n`,(0,t.jsx)(e.span,{className:\"hljs-meta prompt_\",children:\"# \"}),(0,t.jsx)(e.span,{className:\"bash\",children:\"NAME:           example.sh\"}),`\n`,(0,t.jsx)(e.span,{className:\"hljs-meta prompt_\",children:\"# \"}),(0,t.jsx)(e.span,{className:\"bash\",children:\"PURPOSE:        example of executable documentation\"}),`\n`,(0,t.jsx)(e.span,{className:\"hljs-meta prompt_\",children:\"# \"}),(0,t.jsx)(e.span,{className:\"bash\",children:\"VERSION:  1.0   Initial version\"}),`\n`,(0,t.jsx)(e.span,{className:\"hljs-meta prompt_\",children:\"# \"}),(0,t.jsx)(e.span,{className:\"bash\",children:\"------------------------------------------------------------\"}),`\nset -e\n`,(0,t.jsx)(e.span,{className:\"hljs-meta prompt_\",children:`\n# `}),(0,t.jsx)(e.span,{className:\"bash\",children:\"Default settings\"}),`\nPROGNAME=$0\nVER=\"1.0\"\n\nstep_1 () {\n    echo \"Do step 1, press (y, enter) when complete.\"\n    read -r response\n    case $response in\n    [yY])\n        echo \"Step 1 completed.\\\\n\"\n        ;;\n    *)\n        echo \"Step 1 NOT completed.\\\\n\"\n        exit 1\n        ;;\n    esac\n}\n\nstep_2 () {\n    echo \"Do step 2, press (y, enter) when complete.\"\n    read -r response\n    case $response in\n    [yY])\n        echo \"Step 2 completed.\\\\n\"\n        ;;\n    *)\n        echo \"Step 2 NOT completed.\\\\n\"\n        exit 1\n        ;;\n    esac\n}\n\nstep_3 () {\n    echo \"Do step 3, press (y, enter) when complete.\"\n    read -r response\n    case $response in\n    [yY])\n        echo \"Step 3 completed.\\\\n\"\n        ;;\n    *)\n        echo \"Step 3 NOT completed.\\\\n\"\n        exit 1\n        ;;\n    esac\n}\n\nmain() {\n    echo \"Running: \\${PROGNAME}, version \\${VER}.\\\\n\"\n    step_1\n    step_2\n    step_3\n    echo \"All Done!\"\n    echo \"Wouldn't it be great if this was automated?\"\n}\n\nmain \"$@\"\n`]})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Notice this script \",(0,t.jsx)(e.strong,{children:\"doesn\\u2019t actually do any of the steps of the procedure\"}),\"! It feeds the user a step at a time and waits for them to complete each step manually. These scripts will have little logic, and make little use of variables. They can also have a .txt filename to ensure that people understand, that first of all, this is a set of instructions for how to do something, which also just so happens to be a valid shell script.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"At first glance, it might not be obvious that this script provides any value, but the value is immense. First, these scripts actually do something: they allow storing and updating the \",(0,t.jsx)(e.em,{children:\"state\"}),\" of a process. By having these scripts run in a shell rather than in your head, the current state is stored in a machine, not your brain.\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:\"It\\u2019s now much less likely that you\\u2019ll lose your place and skip a step. This makes it easier to maintain focus on the actual work and power through the slog. You can even exit the script and it will tell you where you stopped.\"}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:\"Each step of the procedure is now encapsulated in a function, which makes it possible to replace the text in any given step with code that actually performs the action.\"}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:\"Over time, you\\u2019ll develop a library of useful steps, which will make future automation tasks more efficient.\"}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:\"It will lower the inhibition to automation - each run you can just automate one or two more steps.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Executable documentation doesn\\u2019t initially save your team any manual effort. However, \",(0,t.jsx)(e.strong,{children:\"it lowers the activation energy for automating tasks\"}),\", which allows the team to eliminate toil over time.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"For example I have a process to reinstall the operating system on my personal laptop from scratch, based on a checklist. I'd always wanted to automate it but it just seemed like such a daunting task that I never ended up doing it. The frequency of use didn't seem to warrant the effort.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Last time I turned the checklist into a script, telling me what to do at each step. Then, since I was scripting rather writing a document I also implemented the ones that are easy to automate. I planned to automate a few more items each time I ran the checklist, until it's fully automated. A funny thing happened though - after few runs I had autmated a large portion of the steps, and that motivated me to just knock it out and finish. This is the power of executable documentation.\"}),`\n`,(0,t.jsx)(e.p,{children:'Executable documentation as concept can be very broad - many producst are based around the idea of complex tasks \"as code\". Products like:'}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://aws.amazon.com/cloudformation/\",children:\"AWS Cloudformation\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.terraform.io\",children:\"Hashicorp Terraform\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.chef.io/\",children:\"Chef\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://puppet.com\",children:\"Puppet\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.ansible.com/\",children:\"Ansible\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://jupyter.org\",children:\"Jupyter\"})}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"So you can take this concept pretty far!\"}),`\n`,(0,t.jsx)(e.h4,{id:\"resources\",children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://queue.acm.org/detail.cfm?id=3197520\",children:\"Manual work is a bug\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.youtube.com/watch?v=tweyWNr6X18\",children:\"Record shell sessions\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.newyorker.com/magazine/2007/12/10/the-checklist\",children:\"NYT - The Checklist\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://blog.nuclino.com/the-simple-genius-of-checklists-from-b-17-to-the-apollo-missions\",children:\"The Simple Genius of Checklists, from B-17 to the Apollo Missions\"})}),`\n`]})]})}function v(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(h,n)})):h(n)}var x=v;return b(N);})();\n;return Component;"
  },
  "_id": "posts/2019-08-07-executable-documentation.mdx",
  "_raw": {
    "sourceFilePath": "posts/2019-08-07-executable-documentation.mdx",
    "sourceFileName": "2019-08-07-executable-documentation.mdx",
    "sourceFileDir": "posts",
    "contentType": "mdx",
    "flattenedPath": "posts/2019-08-07-executable-documentation"
  },
  "type": "Post",
  "slug": "/posts/2019-08-07-executable-documentation",
  "slugAsParams": "2019-08-07-executable-documentation",
  "stats": {
    "text": "5 min read",
    "minutes": 4.435,
    "time": 266100,
    "words": 887
  }
}