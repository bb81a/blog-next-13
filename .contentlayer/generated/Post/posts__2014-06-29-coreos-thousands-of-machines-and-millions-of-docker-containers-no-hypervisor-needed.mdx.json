{
  "title": "CoreOS: thousands of machines and millions of Docker containers... no hypervisor needed.",
  "excerpt": "I have been playing around with CoreOS to get a sense of how everything works. The vision of this project is incredible. CoreOS describes itself as \"a new Linux distribution that has been re-architected to provide features needed to run modern infrastructure stacks. The strategies and architectures that influence CoreOS allow companies like Google, Facebook and Twitter to run their services at scale with high resilience.\"",
  "coverImage": "/assets/blog/img/coreos_2.png",
  "date": "2014-06-29T00:00:00.000Z",
  "published": true,
  "author": {
    "name": "Dan Stroot",
    "picture": "/assets/blog/authors/dan.jpeg",
    "type": "Author",
    "_raw": {}
  },
  "ogImage": {
    "url": "/assets/blog/img/coreos_2.png",
    "type": "OGImage",
    "_raw": {}
  },
  "seoURL": "https://danstroot.com/2014/06/28/coreos-thousands-of-machines-and-millions-of-docker-containers-no-hypervisor-needed/",
  "body": {
    "raw": "\nI have been playing around with CoreOS to get a sense of how everything works. The vision of this project is incredible.\n\nCoreOS describes itself as _\"a new Linux distribution that has been re-architected to provide features needed to run modern infrastructure stacks. The strategies and architectures that influence CoreOS allow companies like Google, Facebook and Twitter to run their services at scale with high resilience.\"_\n\nCoreOS displaces hypervisors and machine virtualization in favor of Docker and Linux containers. CoreOS uses Linux containers to manage your services at a high level of abstraction. A single service's code and all dependencies are packaged within a container that can be run on one or many CoreOS machines.\n\nClustering works across platforms, meaning there is no cloud vendor lock-in. For example, CoreOS runs on Amazon EC2, Rackspace, QEMU/KVM, VMware and OpenStack and your own hardware. Running a single CoreOS cluster on multiple different clouds or cloud + bare metal is supported and encouraged. This lack of lock-in is the reason why I have supported OpenStack and CoreOS takes this even further.\n\n#### We begin with concept of a large fleet of machines that start (and remain) exactly consistent at the OS level\n\n- First, think of CoreOS somewhat like you might think of a hypervisor today. It is the first layer you put down on bare metal, or as a virtual machine in a cloud. It is a \"bare minimum\" Linux-based OS that supports Linux LXC containers.\n- It is designed to run as a large fleet (hive?) of machines. It includes built-in primitives such as distributed locking and master election, plus key services necessary to manage the fleet of machines. (more on this later).\n- It is meant to always be consistent across machines.\n  - CoreOS utilizes an active/passive dual-partition scheme to update the OS as a _single unit_ instead of _package by package_.\n  - CoreOS also has the tenant of **automatically** updating itself. This avoids the issue of inconsistent state from machine to machine within a large cluster. Conceptually this is roughly like a self-updating hypervisor.\n  - Each machine has to acquire and hold a reboot lock before it is allowed to reboot. The reboot lock is held until the machine releases it after a successful update. The number of machines allowed to reboot simultaneously is configurable. The main goal to allow for an update to be applied to a fleet quickly, without impacting capacity for the services running on the cluster.\n\n#### Next, we have the concept that the fleet of machines is simply a single pool of compute resources\n\n- You treat your CoreOS cluster as if it has a single, shared init system - one giant systemd if you will.\n- Instead of running a service on a specific machine, services are submitted to the cluster via the cluster manager, fleetctl, which decides where they should run.\n- Your services/applications are in containers that act as small, ephemeral units that can easily migrate around a cluster of self-updating CoreOS machines.\n- It is smart enough to distribute services across a cluster using machine-level affinity or anti-affinity.\n- If your application consists of 5 containers fleet will guarantee that they stay running somewhere on the cluster. If a machine fails or needs to be updated, containers running on that machine will be moved to other qualified machines in the cluster.\n\n#### ... with a single, shared brain\n\n- CoreOS provides a distributed key value store called \"etcd\".\n- The etcd client runs on each machine in a cluster. etcd gracefully handles master election during network partitions and the loss of the current master.\n- Docker containers can read, write and listen to etcd over the docker0 network interface. With these three actions you construct extremely sophisticated orchestration to happen whenever etcd values change. An example of this would be listening for changes and then to reconfigure an upstream proxy when a new container of an application is started.\n- Since etcd is replicated, all changes are reflected across the entire cluster. Your application can always reach the local etcd instance at 127.0.0.1:4001.\n- Your applications can read and write data into etcd. Common examples are storing database connection details, cache settings, feature flags, and more. Let's say we're running a simple web app like Wordpress. Instead of hardcoding our database address with in the config file, we'll fetch it from etcd instead. It's as simple as curl-ing [http://127.0.0.1:4001/v1/keys/database](http://127.0.0.1:4001/v1/keys/database) and using the response within your DB connection code.\n\n### Summary\n\nSo now we have a hive of self-updating Linux hosts with a single, distributed init system (systemd and fleet) and a single shared brain (etcd). It looks something like this:\n\n![CoreOS in Action](https://danstroot.imgix.net/assets/blog/img/coreos-action.png)\n\nThis depicts eight containers (two load balancers and six api servers) being managed by \"fleet\" to run in various CoreOS hosts in the cluster, with shared access to etcd.\n\nMomentum is shifting this way rapidly. Earlier this month Rackspace announced [OnMetal](https://www.rackspace.com/blog/onmetal-the-right-way-to-scale/). Rackspace's OnMetal Cloud Service is the first of its kind. Using OnMetal you create machine instances using OpenStack APIs but, instead of being provisioned a virtual machine, you are provisioned **on physical hardware**. OnMetal servers are single-tenant, bare-metal servers provisioned via the OpenStack API and can be spun up as quickly as VMs.\n\nOnce OnMetal is live, you'll be able to provision CoreOS instances on Rackspace's OnMetalcloud. This combination gives you the ease of spinning up machines with the click of a mouse, the security of running CoreOS with automatic updates, and the raw horsepower of running on bare metal. Pretty impressive!\n",
    "code": "var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)s(t,i,{get:e[i],enumerable:!0})},o=(t,e,i,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of p(e))!g.call(t,a)&&a!==i&&s(t,a,{get:()=>e[a],enumerable:!(r=u(e,a))||r.enumerable});return t};var y=(t,e,i)=>(i=t!=null?d(m(t)):{},o(e||!t||!t.__esModule?s(i,\"default\",{value:t,enumerable:!0}):i,t)),b=t=>o(s({},\"__esModule\",{value:!0}),t);var l=f((x,c)=>{c.exports=_jsx_runtime});var S={};w(S,{default:()=>O,frontmatter:()=>v});var n=y(l()),v={title:\"CoreOS: thousands of machines and millions of Docker containers... no hypervisor needed.\",excerpt:'I have been playing around with CoreOS to get a sense of how everything works. The vision of this project is incredible. CoreOS describes itself as \"a new Linux distribution that has been re-architected to provide features needed to run modern infrastructure stacks. The strategies and architectures that influence CoreOS allow companies like Google, Facebook and Twitter to run their services at scale with high resilience.\"',coverImage:\"/assets/blog/img/coreos_2.png\",date:\"2014-06-29\",published:!0,author:{name:\"Dan Stroot\",picture:\"/assets/blog/authors/dan.jpeg\"},ogImage:{url:\"/assets/blog/img/coreos_2.png\"},seoURL:\"https://danstroot.com/2014/06/28/coreos-thousands-of-machines-and-millions-of-docker-containers-no-hypervisor-needed/\"};function h(t){let e=Object.assign({p:\"p\",em:\"em\",h4:\"h4\",ul:\"ul\",li:\"li\",strong:\"strong\",a:\"a\",h3:\"h3\",img:\"img\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"I have been playing around with CoreOS to get a sense of how everything works. The vision of this project is incredible.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"CoreOS describes itself as \",(0,n.jsx)(e.em,{children:'\"a new Linux distribution that has been re-architected to provide features needed to run modern infrastructure stacks. The strategies and architectures that influence CoreOS allow companies like Google, Facebook and Twitter to run their services at scale with high resilience.\"'})]}),`\n`,(0,n.jsx)(e.p,{children:\"CoreOS displaces hypervisors and machine virtualization in favor of Docker and Linux containers. CoreOS uses Linux containers to manage your services at a high level of abstraction. A single service's code and all dependencies are packaged within a container that can be run on one or many CoreOS machines.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Clustering works across platforms, meaning there is no cloud vendor lock-in. For example, CoreOS runs on Amazon EC2, Rackspace, QEMU/KVM, VMware and OpenStack and your own hardware. Running a single CoreOS cluster on multiple different clouds or cloud + bare metal is supported and encouraged. This lack of lock-in is the reason why I have supported OpenStack and CoreOS takes this even further.\"}),`\n`,(0,n.jsx)(e.h4,{id:\"we-begin-with-concept-of-a-large-fleet-of-machines-that-start-and-remain-exactly-consistent-at-the-os-level\",children:\"We begin with concept of a large fleet of machines that start (and remain) exactly consistent at the OS level\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:'First, think of CoreOS somewhat like you might think of a hypervisor today. It is the first layer you put down on bare metal, or as a virtual machine in a cloud. It is a \"bare minimum\" Linux-based OS that supports Linux LXC containers.'}),`\n`,(0,n.jsx)(e.li,{children:\"It is designed to run as a large fleet (hive?) of machines. It includes built-in primitives such as distributed locking and master election, plus key services necessary to manage the fleet of machines. (more on this later).\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"It is meant to always be consistent across machines.\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"CoreOS utilizes an active/passive dual-partition scheme to update the OS as a \",(0,n.jsx)(e.em,{children:\"single unit\"}),\" instead of \",(0,n.jsx)(e.em,{children:\"package by package\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"CoreOS also has the tenant of \",(0,n.jsx)(e.strong,{children:\"automatically\"}),\" updating itself. This avoids the issue of inconsistent state from machine to machine within a large cluster. Conceptually this is roughly like a self-updating hypervisor.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Each machine has to acquire and hold a reboot lock before it is allowed to reboot. The reboot lock is held until the machine releases it after a successful update. The number of machines allowed to reboot simultaneously is configurable. The main goal to allow for an update to be applied to a fleet quickly, without impacting capacity for the services running on the cluster.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h4,{id:\"next-we-have-the-concept-that-the-fleet-of-machines-is-simply-a-single-pool-of-compute-resources\",children:\"Next, we have the concept that the fleet of machines is simply a single pool of compute resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"You treat your CoreOS cluster as if it has a single, shared init system - one giant systemd if you will.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Instead of running a service on a specific machine, services are submitted to the cluster via the cluster manager, fleetctl, which decides where they should run.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Your services/applications are in containers that act as small, ephemeral units that can easily migrate around a cluster of self-updating CoreOS machines.\"}),`\n`,(0,n.jsx)(e.li,{children:\"It is smart enough to distribute services across a cluster using machine-level affinity or anti-affinity.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If your application consists of 5 containers fleet will guarantee that they stay running somewhere on the cluster. If a machine fails or needs to be updated, containers running on that machine will be moved to other qualified machines in the cluster.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h4,{id:\"-with-a-single-shared-brain\",children:\"... with a single, shared brain\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:'CoreOS provides a distributed key value store called \"etcd\".'}),`\n`,(0,n.jsx)(e.li,{children:\"The etcd client runs on each machine in a cluster. etcd gracefully handles master election during network partitions and the loss of the current master.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Docker containers can read, write and listen to etcd over the docker0 network interface. With these three actions you construct extremely sophisticated orchestration to happen whenever etcd values change. An example of this would be listening for changes and then to reconfigure an upstream proxy when a new container of an application is started.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Since etcd is replicated, all changes are reflected across the entire cluster. Your application can always reach the local etcd instance at 127.0.0.1:4001.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Your applications can read and write data into etcd. Common examples are storing database connection details, cache settings, feature flags, and more. Let's say we're running a simple web app like Wordpress. Instead of hardcoding our database address with in the config file, we'll fetch it from etcd instead. It's as simple as curl-ing \",(0,n.jsx)(e.a,{href:\"http://127.0.0.1:4001/v1/keys/database\",children:\"http://127.0.0.1:4001/v1/keys/database\"}),\" and using the response within your DB connection code.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{id:\"summary\",children:\"Summary\"}),`\n`,(0,n.jsx)(e.p,{children:\"So now we have a hive of self-updating Linux hosts with a single, distributed init system (systemd and fleet) and a single shared brain (etcd). It looks something like this:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"https://danstroot.imgix.net/assets/blog/img/coreos-action.png\",alt:\"CoreOS in Action\"})}),`\n`,(0,n.jsx)(e.p,{children:'This depicts eight containers (two load balancers and six api servers) being managed by \"fleet\" to run in various CoreOS hosts in the cluster, with shared access to etcd.'}),`\n`,(0,n.jsxs)(e.p,{children:[\"Momentum is shifting this way rapidly. Earlier this month Rackspace announced \",(0,n.jsx)(e.a,{href:\"https://www.rackspace.com/blog/onmetal-the-right-way-to-scale/\",children:\"OnMetal\"}),\". Rackspace's OnMetal Cloud Service is the first of its kind. Using OnMetal you create machine instances using OpenStack APIs but, instead of being provisioned a virtual machine, you are provisioned \",(0,n.jsx)(e.strong,{children:\"on physical hardware\"}),\". OnMetal servers are single-tenant, bare-metal servers provisioned via the OpenStack API and can be spun up as quickly as VMs.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Once OnMetal is live, you'll be able to provision CoreOS instances on Rackspace's OnMetalcloud. This combination gives you the ease of spinning up machines with the click of a mouse, the security of running CoreOS with automatic updates, and the raw horsepower of running on bare metal. Pretty impressive!\"})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var O=k;return b(S);})();\n;return Component;"
  },
  "_id": "posts/2014-06-29-coreos-thousands-of-machines-and-millions-of-docker-containers-no-hypervisor-needed.mdx",
  "_raw": {
    "sourceFilePath": "posts/2014-06-29-coreos-thousands-of-machines-and-millions-of-docker-containers-no-hypervisor-needed.mdx",
    "sourceFileName": "2014-06-29-coreos-thousands-of-machines-and-millions-of-docker-containers-no-hypervisor-needed.mdx",
    "sourceFileDir": "posts",
    "contentType": "mdx",
    "flattenedPath": "posts/2014-06-29-coreos-thousands-of-machines-and-millions-of-docker-containers-no-hypervisor-needed"
  },
  "type": "Post",
  "slug": "/posts/2014-06-29-coreos-thousands-of-machines-and-millions-of-docker-containers-no-hypervisor-needed",
  "slugAsParams": "2014-06-29-coreos-thousands-of-machines-and-millions-of-docker-containers-no-hypervisor-needed",
  "stats": {
    "text": "5 min read",
    "minutes": 4.63,
    "time": 277800,
    "words": 926
  }
}