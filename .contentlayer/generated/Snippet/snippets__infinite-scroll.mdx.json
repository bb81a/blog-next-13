{
  "title": "Infinite Scroll",
  "summary": "This is a clean, understandable way to implement an infinite scroll in a React/Next application. Cheers!",
  "icon": "react",
  "date": "2021-12-23T00:00:00.000Z",
  "published": false,
  "tags": [
    "Javascript",
    "React Component"
  ],
  "body": {
    "raw": "\nThis is a simple example of how to implement an infinite scrolling application in React. What we are doing is tracking if an image is visible in the viewport (actually the image **before** the last image ). When it is visible, increment the page count - which in turn will kick off another API call and get more images.\n\nA fully working codebase is [here](https://github.com/dstroot/react-infinite-scroll), and deployed on Netlify [here](). In this example we are using images from\n\n<Step number={1} title='The \"driver\" function' />\n\nThis simple function drives our \"infinite scroll\". If the visible image in the viewport is the next to last image, then increment the page (which kicks off another API call as you will see in the next step).\n\n<CodeBlock>\n\n```javascript\nconst onIsVisible = (index) => {\n  if (index === images.length - 1) {\n    setPage((page) => page + 1);\n  }\n};\n```\n\n</CodeBlock>\n\n<Step number={2} title='When the page changes run the effect and get more photos!' />\n\nThis effect is run each time a page changes (is incremented). It will fetch more photos from the API and concatenate them to our images array.\n\n<CodeBlock>\n\n```javascript\nuseEffect(() => {\n  const fetchPhotos = async (page) => {\n    setLoading(true);\n    try {\n      const data = await fetch(`/api/photos?page=${page}`);\n      const morePhotos = await data.json();\n      setImages((photos) => {\n        return photos.concat(morePhotos); // notice concatination for infinite scroll\n      });\n    } catch (e) {\n      setError(true);\n    }\n    setLoading(false);\n  };\n  fetchPhotos(page);\n}, [page]); // if the page changes run the effect\n```\n\n</CodeBlock>\n\n<Step number={3} title='Map the array of images' />\n\nThis puts it all together. Get some images, and as the user scrolls down, when the next to last image is visible, get more images and concatenate them to our images array. This will cause React to update the DOM with the new images.\n\n<CodeBlock>\n\n```javascript\nimport React, { useEffect } from 'react';\nimport { ImageContainer } from './components/ImageContainer';\nimport './App.css';\n\nfunction App() {\n  const [loading, setLoading] = React.useState(false);\n  const [images, setImages] = React.useState([]);\n  const [error, setError] = React.useState(false);\n  const [page, setPage] = React.useState(1);\n\n  // This is our \"infinite scroll\".  If the visible image is the next\n  // to last image, then increment the page, which kicks off another API call\n  const onIsVisible = (index) => {\n    if (index === images.length - 1) {\n      setPage((page) => page + 1);\n    }\n  };\n\n  const checkForError = (response) => {\n    if (!response.ok) throw Error(response.statusText);\n    return response;\n  };\n\n  useEffect(() => {\n    const fetchPhotos = async (page) => {\n      setLoading(true);\n      try {\n        const result = await fetch(`/.netlify/functions/photos?page=${page}`);\n        const photoResult = await checkForError(result).json();\n        setImages((photos) => {\n          return photos.concat(photoResult); // notice concatination for infinite scroll\n        });\n      } catch (e) {\n        setError(true);\n      }\n      setLoading(false);\n    };\n    fetchPhotos(page);\n  }, [page]); // if \"page\" changes run effect\n\n  return (\n    <div className='app'>\n      <div className='container'>\n        {error && <div>Error occured. Please refresh page and try again.</div>}\n        {images.map((res, index) => {\n          return (\n            <div key={`${res.id}-${index}`} className='wrapper'>\n              <ImageContainer\n                src={res.urls.regular}\n                thumb={res.urls.thumb}\n                height={res.height}\n                width={res.width}\n                alt={res.alt_description}\n                url={res.links.html}\n                onIsVisible={() => onIsVisible(index)}\n              />\n            </div>\n          );\n        })}\n        {loading && <div>Loading...</div>}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n```\n\n</CodeBlock>\n\n<CodeBlock>\n\n```javascript\nimport React from 'react';\nimport { Image } from '../Image';\nimport useIntersectionObserver from '../../hooks/use-intersection-observer';\nimport './image-container.css';\n\nexport const ImageContainer = ({ src, thumb, height, width, alt, url, onIsVisible }) => {\n  const ref = React.useRef();\n  const [isVisible, setIsVisible] = React.useState(false);\n\n  useIntersectionObserver({\n    target: ref,\n    onIntersect: ([{ isIntersecting }], observerElement) => {\n      if (isIntersecting) {\n        if (!isVisible) {\n          onIsVisible();\n          setIsVisible(true);\n        }\n        observerElement.unobserve(ref.current);\n      }\n    },\n  });\n\n  const aspectRatio = (height / width) * 100;\n\n  return (\n    <a\n      href={url}\n      ref={ref}\n      rel='noopener noreferrer'\n      target='_BLANK'\n      className='image-container'\n      style={{ paddingBottom: `${aspectRatio}%` }}\n    >\n      {isVisible && <Image src={src} thumb={thumb} alt={alt} />}\n    </a>\n  );\n};\n```\n\n</CodeBlock>\n\n<CodeBlock>\n\n```javascript\nimport { useEffect } from 'react';\n\n/**\nThe Intersection Observer API allows you to configure a callback that is called whenever \none element, called the target, intersects either the device viewport or a specified \nelement; for the purpose of this API, this is called the root element or root. \n\nrootMargin: Margin around the root. Serves to grow or shrink each side of the root \nelement's bounding box before computing intersections. \n\nthreshold: at what percentage of the target's visibility the observer's callback \nshould be executed\n */\n\nconst useIntersectionObserver = ({\n  target,\n  onIntersect, // callback\n  threshold = 0.2, // when 20% visible\n  rootMargin = '0px', // don't adjust viewport margin\n}) => {\n  useEffect(() => {\n    if (!target) {\n      return;\n    }\n\n    const observer = new IntersectionObserver(onIntersect, {\n      rootMargin,\n      threshold,\n    });\n\n    // Once you have created the observer, you need to give it a target element to watch\n    const current = target.current;\n    observer.observe(current);\n\n    // clean up our observer\n    return () => {\n      observer.unobserve(current);\n    };\n  });\n};\n\nexport default useIntersectionObserver;\n```\n\n</CodeBlock>\n",
    "code": "var Component=(()=>{var m=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var j=Object.getOwnPropertyNames;var N=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var u=(a,s)=>()=>(s||a((s={exports:{}}).exports,s),s.exports),f=(a,s)=>{for(var n in s)r(a,n,{get:s[n],enumerable:!0})},t=(a,s,n,l)=>{if(s&&typeof s==\"object\"||typeof s==\"function\")for(let c of j(s))!g.call(a,c)&&c!==n&&r(a,c,{get:()=>s[c],enumerable:!(l=p(s,c))||l.enumerable});return a};var w=(a,s,n)=>(n=a!=null?m(N(a)):{},t(s||!a||!a.__esModule?r(n,\"default\",{value:a,enumerable:!0}):n,a)),y=a=>t(r({},\"__esModule\",{value:!0}),a);var h=u((x,i)=>{i.exports=_jsx_runtime});var v={};f(v,{default:()=>_,frontmatter:()=>k});var e=w(h()),k={title:\"Infinite Scroll\",summary:\"This is a clean, understandable way to implement an infinite scroll in a React/Next application. Cheers!\",date:\"2021-12-23\",published:!1,icon:\"react\",tags:[\"Javascript\",\"React Component\"]};function o(a){let s=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",pre:\"pre\",code:\"code\",span:\"span\"},a.components),{Step:n,CodeBlock:l}=s;return l||d(\"CodeBlock\",!0),n||d(\"Step\",!0),(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(s.p,{children:[\"This is a simple example of how to implement an infinite scrolling application in React. What we are doing is tracking if an image is visible in the viewport (actually the image \",(0,e.jsx)(s.strong,{children:\"before\"}),\" the last image ). When it is visible, increment the page count - which in turn will kick off another API call and get more images.\"]}),`\n`,(0,e.jsxs)(s.p,{children:[\"A fully working codebase is \",(0,e.jsx)(s.a,{href:\"https://github.com/dstroot/react-infinite-scroll\",children:\"here\"}),\", and deployed on Netlify \",(0,e.jsx)(s.a,{href:\"\",children:\"here\"}),\". In this example we are using images from\"]}),`\n`,(0,e.jsx)(n,{number:1,title:'The \"driver\" function'}),`\n`,(0,e.jsx)(s.p,{children:'This simple function drives our \"infinite scroll\". If the visible image in the viewport is the next to last image, then increment the page (which kicks off another API call as you will see in the next step).'}),`\n`,(0,e.jsx)(l,{children:(0,e.jsx)(s.pre,{children:(0,e.jsxs)(s.code,{className:\"hljs language-javascript\",children:[(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"onIsVisible\"}),\" = (\",(0,e.jsx)(s.span,{className:\"hljs-params\",children:\"index\"}),`) => {\n  `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"if\"}),\" (index === images.\",(0,e.jsx)(s.span,{className:\"hljs-property\",children:\"length\"}),\" - \",(0,e.jsx)(s.span,{className:\"hljs-number\",children:\"1\"}),`) {\n    `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"setPage\"}),\"(\",(0,e.jsxs)(s.span,{className:\"hljs-function\",children:[\"(\",(0,e.jsx)(s.span,{className:\"hljs-params\",children:\"page\"}),\") =>\"]}),\" page + \",(0,e.jsx)(s.span,{className:\"hljs-number\",children:\"1\"}),`);\n  }\n};\n`]})})}),`\n`,(0,e.jsx)(n,{number:2,title:\"When the page changes run the effect and get more photos!\"}),`\n`,(0,e.jsx)(s.p,{children:\"This effect is run each time a page changes (is incremented). It will fetch more photos from the API and concatenate them to our images array.\"}),`\n`,(0,e.jsx)(l,{children:(0,e.jsx)(s.pre,{children:(0,e.jsxs)(s.code,{className:\"hljs language-javascript\",children:[(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"useEffect\"}),\"(\",(0,e.jsx)(s.span,{className:\"hljs-function\",children:\"() =>\"}),` {\n  `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"fetchPhotos\"}),\" = \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"async\"}),\" (\",(0,e.jsx)(s.span,{className:\"hljs-params\",children:\"page\"}),`) => {\n    `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"setLoading\"}),\"(\",(0,e.jsx)(s.span,{className:\"hljs-literal\",children:\"true\"}),`);\n    `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"try\"}),` {\n      `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" data = \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"await\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"fetch\"}),\"(\",(0,e.jsxs)(s.span,{className:\"hljs-string\",children:[\"`/api/photos?page=\",(0,e.jsx)(s.span,{className:\"hljs-subst\",children:\"${page}\"}),\"`\"]}),`);\n      `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" morePhotos = \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"await\"}),\" data.\",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"json\"}),`();\n      `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"setImages\"}),\"(\",(0,e.jsxs)(s.span,{className:\"hljs-function\",children:[\"(\",(0,e.jsx)(s.span,{className:\"hljs-params\",children:\"photos\"}),\") =>\"]}),` {\n        `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"return\"}),\" photos.\",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"concat\"}),\"(morePhotos); \",(0,e.jsx)(s.span,{className:\"hljs-comment\",children:\"// notice concatination for infinite scroll\"}),`\n      });\n    } `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"catch\"}),` (e) {\n      `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"setError\"}),\"(\",(0,e.jsx)(s.span,{className:\"hljs-literal\",children:\"true\"}),`);\n    }\n    `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"setLoading\"}),\"(\",(0,e.jsx)(s.span,{className:\"hljs-literal\",children:\"false\"}),`);\n  };\n  `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"fetchPhotos\"}),`(page);\n}, [page]); `,(0,e.jsx)(s.span,{className:\"hljs-comment\",children:\"// if the page changes run the effect\"}),`\n`]})})}),`\n`,(0,e.jsx)(n,{number:3,title:\"Map the array of images\"}),`\n`,(0,e.jsx)(s.p,{children:\"This puts it all together. Get some images, and as the user scrolls down, when the next to last image is visible, get more images and concatenate them to our images array. This will cause React to update the DOM with the new images.\"}),`\n`,(0,e.jsx)(l,{children:(0,e.jsx)(s.pre,{children:(0,e.jsxs)(s.code,{className:\"hljs language-javascript\",children:[(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"import\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title class_\",children:\"React\"}),\", { useEffect } \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"from\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'react'\"}),`;\n`,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"import\"}),\" { \",(0,e.jsx)(s.span,{className:\"hljs-title class_\",children:\"ImageContainer\"}),\" } \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"from\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'./components/ImageContainer'\"}),`;\n`,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"import\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'./App.css'\"}),`;\n\n`,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"function\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"App\"}),\"(\",(0,e.jsx)(s.span,{className:\"hljs-params\"}),`) {\n  `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" [loading, setLoading] = \",(0,e.jsx)(s.span,{className:\"hljs-title class_\",children:\"React\"}),\".\",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"useState\"}),\"(\",(0,e.jsx)(s.span,{className:\"hljs-literal\",children:\"false\"}),`);\n  `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" [images, setImages] = \",(0,e.jsx)(s.span,{className:\"hljs-title class_\",children:\"React\"}),\".\",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"useState\"}),`([]);\n  `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" [error, setError] = \",(0,e.jsx)(s.span,{className:\"hljs-title class_\",children:\"React\"}),\".\",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"useState\"}),\"(\",(0,e.jsx)(s.span,{className:\"hljs-literal\",children:\"false\"}),`);\n  `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" [page, setPage] = \",(0,e.jsx)(s.span,{className:\"hljs-title class_\",children:\"React\"}),\".\",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"useState\"}),\"(\",(0,e.jsx)(s.span,{className:\"hljs-number\",children:\"1\"}),`);\n\n  `,(0,e.jsx)(s.span,{className:\"hljs-comment\",children:'// This is our \"infinite scroll\".  If the visible image is the next'}),`\n  `,(0,e.jsx)(s.span,{className:\"hljs-comment\",children:\"// to last image, then increment the page, which kicks off another API call\"}),`\n  `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"onIsVisible\"}),\" = (\",(0,e.jsx)(s.span,{className:\"hljs-params\",children:\"index\"}),`) => {\n    `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"if\"}),\" (index === images.\",(0,e.jsx)(s.span,{className:\"hljs-property\",children:\"length\"}),\" - \",(0,e.jsx)(s.span,{className:\"hljs-number\",children:\"1\"}),`) {\n      `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"setPage\"}),\"(\",(0,e.jsxs)(s.span,{className:\"hljs-function\",children:[\"(\",(0,e.jsx)(s.span,{className:\"hljs-params\",children:\"page\"}),\") =>\"]}),\" page + \",(0,e.jsx)(s.span,{className:\"hljs-number\",children:\"1\"}),`);\n    }\n  };\n\n  `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"checkForError\"}),\" = (\",(0,e.jsx)(s.span,{className:\"hljs-params\",children:\"response\"}),`) => {\n    `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"if\"}),\" (!response.\",(0,e.jsx)(s.span,{className:\"hljs-property\",children:\"ok\"}),\") \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"throw\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title class_\",children:\"Error\"}),\"(response.\",(0,e.jsx)(s.span,{className:\"hljs-property\",children:\"statusText\"}),`);\n    `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"return\"}),` response;\n  };\n\n  `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"useEffect\"}),\"(\",(0,e.jsx)(s.span,{className:\"hljs-function\",children:\"() =>\"}),` {\n    `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"fetchPhotos\"}),\" = \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"async\"}),\" (\",(0,e.jsx)(s.span,{className:\"hljs-params\",children:\"page\"}),`) => {\n      `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"setLoading\"}),\"(\",(0,e.jsx)(s.span,{className:\"hljs-literal\",children:\"true\"}),`);\n      `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"try\"}),` {\n        `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" result = \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"await\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"fetch\"}),\"(\",(0,e.jsxs)(s.span,{className:\"hljs-string\",children:[\"`/.netlify/functions/photos?page=\",(0,e.jsx)(s.span,{className:\"hljs-subst\",children:\"${page}\"}),\"`\"]}),`);\n        `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" photoResult = \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"await\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"checkForError\"}),\"(result).\",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"json\"}),`();\n        `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"setImages\"}),\"(\",(0,e.jsxs)(s.span,{className:\"hljs-function\",children:[\"(\",(0,e.jsx)(s.span,{className:\"hljs-params\",children:\"photos\"}),\") =>\"]}),` {\n          `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"return\"}),\" photos.\",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"concat\"}),\"(photoResult); \",(0,e.jsx)(s.span,{className:\"hljs-comment\",children:\"// notice concatination for infinite scroll\"}),`\n        });\n      } `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"catch\"}),` (e) {\n        `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"setError\"}),\"(\",(0,e.jsx)(s.span,{className:\"hljs-literal\",children:\"true\"}),`);\n      }\n      `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"setLoading\"}),\"(\",(0,e.jsx)(s.span,{className:\"hljs-literal\",children:\"false\"}),`);\n    };\n    `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"fetchPhotos\"}),`(page);\n  }, [page]); `,(0,e.jsx)(s.span,{className:\"hljs-comment\",children:'// if \"page\" changes run effect'}),`\n\n  `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"return\"}),` (\n    `,(0,e.jsxs)(s.span,{className:\"xml\",children:[(0,e.jsxs)(s.span,{className:\"hljs-tag\",children:[\"<\",(0,e.jsx)(s.span,{className:\"hljs-name\",children:\"div\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'app'\"}),\">\"]}),`\n      `,(0,e.jsxs)(s.span,{className:\"hljs-tag\",children:[\"<\",(0,e.jsx)(s.span,{className:\"hljs-name\",children:\"div\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'container'\"}),\">\"]}),`\n        {error && `,(0,e.jsxs)(s.span,{className:\"hljs-tag\",children:[\"<\",(0,e.jsx)(s.span,{className:\"hljs-name\",children:\"div\"}),\">\"]}),\"Error occured. Please refresh page and try again.\",(0,e.jsxs)(s.span,{className:\"hljs-tag\",children:[\"</\",(0,e.jsx)(s.span,{className:\"hljs-name\",children:\"div\"}),\">\"]}),`}\n        {images.map((res, index) => {\n          return (\n            `,(0,e.jsxs)(s.span,{className:\"hljs-tag\",children:[\"<\",(0,e.jsx)(s.span,{className:\"hljs-name\",children:\"div\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"key\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"{\"}),\"`${\",(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"res.id\"}),\"}\",(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"-\"}),\"${\",(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"index\"}),\"}`} \",(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'wrapper'\"}),\">\"]}),`\n              `,(0,e.jsxs)(s.span,{className:\"hljs-tag\",children:[\"<\",(0,e.jsx)(s.span,{className:\"hljs-name\",children:\"ImageContainer\"}),`\n                `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"src\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"{res.urls.regular}\"}),`\n                `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"thumb\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"{res.urls.thumb}\"}),`\n                `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"height\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"{res.height}\"}),`\n                `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"width\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"{res.width}\"}),`\n                `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"alt\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"{res.alt_description}\"}),`\n                `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"url\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"{res.links.html}\"}),`\n                `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"onIsVisible\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"{()\"}),\" =>\"]}),` onIsVisible(index)}\n              />\n            `,(0,e.jsxs)(s.span,{className:\"hljs-tag\",children:[\"</\",(0,e.jsx)(s.span,{className:\"hljs-name\",children:\"div\"}),\">\"]}),`\n          );\n        })}\n        {loading && `,(0,e.jsxs)(s.span,{className:\"hljs-tag\",children:[\"<\",(0,e.jsx)(s.span,{className:\"hljs-name\",children:\"div\"}),\">\"]}),\"Loading...\",(0,e.jsxs)(s.span,{className:\"hljs-tag\",children:[\"</\",(0,e.jsx)(s.span,{className:\"hljs-name\",children:\"div\"}),\">\"]}),`}\n      `,(0,e.jsxs)(s.span,{className:\"hljs-tag\",children:[\"</\",(0,e.jsx)(s.span,{className:\"hljs-name\",children:\"div\"}),\">\"]}),`\n    `,(0,e.jsxs)(s.span,{className:\"hljs-tag\",children:[\"</\",(0,e.jsx)(s.span,{className:\"hljs-name\",children:\"div\"}),\">\"]})]}),`\n  );\n}\n\n`,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"export\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"default\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title class_\",children:\"App\"}),`;\n`]})})}),`\n`,(0,e.jsx)(l,{children:(0,e.jsx)(s.pre,{children:(0,e.jsxs)(s.code,{className:\"hljs language-javascript\",children:[(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"import\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title class_\",children:\"React\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"from\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'react'\"}),`;\n`,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"import\"}),\" { \",(0,e.jsx)(s.span,{className:\"hljs-title class_\",children:\"Image\"}),\" } \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"from\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'../Image'\"}),`;\n`,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"import\"}),\" useIntersectionObserver \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"from\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'../../hooks/use-intersection-observer'\"}),`;\n`,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"import\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'./image-container.css'\"}),`;\n\n`,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"export\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"ImageContainer\"}),\" = (\",(0,e.jsx)(s.span,{className:\"hljs-params\",children:\"{ src, thumb, height, width, alt, url, onIsVisible }\"}),`) => {\n  `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" ref = \",(0,e.jsx)(s.span,{className:\"hljs-title class_\",children:\"React\"}),\".\",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"useRef\"}),`();\n  `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" [isVisible, setIsVisible] = \",(0,e.jsx)(s.span,{className:\"hljs-title class_\",children:\"React\"}),\".\",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"useState\"}),\"(\",(0,e.jsx)(s.span,{className:\"hljs-literal\",children:\"false\"}),`);\n\n  `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"useIntersectionObserver\"}),`({\n    `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"target\"}),`: ref,\n    `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"onIntersect\"}),\": \",(0,e.jsxs)(s.span,{className:\"hljs-function\",children:[\"(\",(0,e.jsx)(s.span,{className:\"hljs-params\",children:\"[{ isIntersecting }], observerElement\"}),\") =>\"]}),` {\n      `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"if\"}),` (isIntersecting) {\n        `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"if\"}),` (!isVisible) {\n          `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"onIsVisible\"}),`();\n          `,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"setIsVisible\"}),\"(\",(0,e.jsx)(s.span,{className:\"hljs-literal\",children:\"true\"}),`);\n        }\n        observerElement.`,(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"unobserve\"}),\"(ref.\",(0,e.jsx)(s.span,{className:\"hljs-property\",children:\"current\"}),`);\n      }\n    },\n  });\n\n  `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" aspectRatio = (height / width) * \",(0,e.jsx)(s.span,{className:\"hljs-number\",children:\"100\"}),`;\n\n  `,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"return\"}),` (\n    `,(0,e.jsxs)(s.span,{className:\"xml\",children:[(0,e.jsxs)(s.span,{className:\"hljs-tag\",children:[\"<\",(0,e.jsx)(s.span,{className:\"hljs-name\",children:\"a\"}),`\n      `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"href\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"{url}\"}),`\n      `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"ref\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"{ref}\"}),`\n      `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"rel\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'noopener noreferrer'\"}),`\n      `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"target\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'_BLANK'\"}),`\n      `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"className\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'image-container'\"}),`\n      `,(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"style\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"{{\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"paddingBottom:\"}),\" `${\",(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"aspectRatio\"}),\"}%` }}\\n    >\"]}),`\n      {isVisible && `,(0,e.jsxs)(s.span,{className:\"hljs-tag\",children:[\"<\",(0,e.jsx)(s.span,{className:\"hljs-name\",children:\"Image\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"src\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"{src}\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"thumb\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"{thumb}\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-attr\",children:\"alt\"}),\"=\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"{alt}\"}),\" />\"]}),`}\n    `,(0,e.jsxs)(s.span,{className:\"hljs-tag\",children:[\"</\",(0,e.jsx)(s.span,{className:\"hljs-name\",children:\"a\"}),\">\"]})]}),`\n  );\n};\n`]})})}),`\n`,(0,e.jsx)(l,{children:(0,e.jsx)(s.pre,{children:(0,e.jsxs)(s.code,{className:\"hljs language-javascript\",children:[(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"import\"}),\" { useEffect } \",(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"from\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'react'\"}),`;\n\n`,(0,e.jsx)(s.span,{className:\"hljs-comment\",children:`/**\nThe Intersection Observer API allows you to configure a callback that is called whenever \none element, called the target, intersects either the device viewport or a specified \nelement; for the purpose of this API, this is called the root element or root. \n\nrootMargin: Margin around the root. Serves to grow or shrink each side of the root \nelement's bounding box before computing intersections. \n\nthreshold: at what percentage of the target's visibility the observer's callback \nshould be executed\n */`}),`\n\n`,(0,e.jsx)(s.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",(0,e.jsx)(s.span,{className:\"hljs-title function_\",children:\"useIntersectionObserver\"}),\" = (\",(0,e.jsxs)(s.span,{className:\"hljs-params\",children:[`{\n  target,\n  onIntersect, // callback\n  threshold = `,(0,e.jsx)(s.span,{className:\"hljs-number\",children:\"0.2\"}),\", // when \",(0,e.jsx)(s.span,{className:\"hljs-number\",children:\"20\"}),`% visible\n  rootMargin = `,(0,e.jsx)(s.span,{className:\"hljs-string\",children:\"'0px'\"}),\", // don\",(0,e.jsx)(s.span,{className:\"hljs-string\",children:`'t adjust viewport margin\n}) => {\n  useEffect(() => {\n    if (!target) {\n      return;\n    }\n\n    const observer = new IntersectionObserver(onIntersect, {\n      rootMargin,\n      threshold,\n    });\n\n    // Once you have created the observer, you need to give it a target element to watch\n    const current = target.current;\n    observer.observe(current);\n\n    // clean up our observer\n    return () => {\n      observer.unobserve(current);\n    };\n  });\n};\n\nexport default useIntersectionObserver;\n`})]})]})})})]})}function b(a={}){let{wrapper:s}=a.components||{};return s?(0,e.jsx)(s,Object.assign({},a,{children:(0,e.jsx)(o,a)})):o(a)}var _=b;function d(a,s){throw new Error(\"Expected \"+(s?\"component\":\"object\")+\" `\"+a+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return y(v);})();\n;return Component;"
  },
  "_id": "snippets/infinite-scroll.mdx",
  "_raw": {
    "sourceFilePath": "snippets/infinite-scroll.mdx",
    "sourceFileName": "infinite-scroll.mdx",
    "sourceFileDir": "snippets",
    "contentType": "mdx",
    "flattenedPath": "snippets/infinite-scroll"
  },
  "type": "Snippet",
  "slug": "/snippets/infinite-scroll",
  "slugAsParams": "infinite-scroll",
  "stats": {
    "text": "4 min read",
    "minutes": 3.84,
    "time": 230400,
    "words": 768
  }
}