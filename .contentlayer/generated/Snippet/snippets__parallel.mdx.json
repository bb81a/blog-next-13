{
  "title": "Async/await functions in parallel",
  "summary": "To speed up our code lets look at some ways to run promises in parallel. This can be useful when performing multiple database queries to render a web page and you want to run the queries in parallel rather than seqentially.",
  "icon": "js",
  "date": "2023-07-07T00:00:00.000Z",
  "published": true,
  "tags": [
    "Javascript"
  ],
  "body": {
    "raw": "\n### Context\n\nMultiple `await` calls will execute one after the other rather than in parallel. For example:\n\n<CodeBlock>\n\n```JavaScript:await.js\nconst someResult = await someCall();\nconst anotherResult = await anotherCall();\n```\n\n</CodeBlock>\n\nHere `anotherCall()` will be called only when `someCall()` is completed. What if you want to execute them in parallel? \n\nHere's the simplest approach:\n\n<CodeBlock>\n\n```JavaScript:parallel.js\nconst [someResult, anotherResult] = await Promise.all([someCall(), anotherCall()]);\n```\n\n</CodeBlock>\n\nNote that `Promise.all` fails fast, which means that as soon as one of the promises supplied to it rejects, then the entire thing rejects. On the other hand, it will allow all the promises in it to run without blocking each other, but will prevent the execution to continue until ALL are resolved successfully.\n\nFor extra credit - here is a way to run many tasks in parallel and process the results individually as the tasks complete. I think it's pretty elegant.\n\n<CodeBlock>\n\n```JavaScript:tasks.js\nfunction wait(ms, data) {\n    console.log('Starting task:', data, ms);\n    return new Promise(resolve => setTimeout(resolve, ms, data));\n}\n\n// run these in parallel, process results individually\nvar tasks = [\n    async () => {\n        var result = await wait(1000, 'burrito');\n        // do something with result\n        console.log(result);\n    },\n    async () => {\n        var result = await wait(500, 'taco');\n        // do something with result\n        console.log(result);\n    },\n    async () => {\n        var result = await wait(5000, 'tostada');\n        // do something with result\n        console.log(result);\n    }\n]\n\nawait Promise.all(tasks.map(p => p()));\nconsole.log('done');\n```\n\n</CodeBlock>\n\nThere results should look as follows:\n\n<CodeBlock>\n\n```JavaScript:results.js\nStarting task: burrito 1000\nStarting task: taco 500\nStarting task: tostada 5000\ntaco\nburrito\ntostada\ndone\n```\n\n</CodeBlock>\n\n## References\n\n[Understanding Node.js Async Flows: Parallel, Serial, Waterfall and Queues](https://medium.com/velotio-perspectives/understanding-node-js-async-flows-parallel-serial-waterfall-and-queues-6f9c4badbc17)",
    "code": "var Component=(()=>{var d=Object.create;var t=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var N=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),w=(a,e)=>{for(var l in e)t(a,l,{get:e[l],enumerable:!0})},r=(a,e,l,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of m(e))!j.call(a,n)&&n!==l&&t(a,n,{get:()=>e[n],enumerable:!(c=p(e,n))||c.enumerable});return a};var g=(a,e,l)=>(l=a!=null?d(u(a)):{},r(e||!a||!a.__esModule?t(l,\"default\",{value:a,enumerable:!0}):l,a)),f=a=>r(t({},\"__esModule\",{value:!0}),a);var h=N((C,i)=>{i.exports=_jsx_runtime});var b={};w(b,{default:()=>k,frontmatter:()=>y});var s=g(h()),y={title:\"Async/await functions in parallel\",published:!0,date:\"2023-07-07\",summary:\"To speed up our code lets look at some ways to run promises in parallel. This can be useful when performing multiple database queries to render a web page and you want to run the queries in parallel rather than seqentially.\",icon:\"js\",tags:[\"Javascript\"]};function o(a){let e=Object.assign({h3:\"h3\",p:\"p\",code:\"code\",div:\"div\",pre:\"pre\",span:\"span\",h2:\"h2\",a:\"a\"},a.components),{CodeBlock:l}=e;return l||v(\"CodeBlock\",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h3,{id:\"context\",children:\"Context\"}),`\n`,(0,s.jsxs)(e.p,{children:[\"Multiple \",(0,s.jsx)(e.code,{children:\"await\"}),\" calls will execute one after the other rather than in parallel. For example:\"]}),`\n`,(0,s.jsxs)(l,{children:[(0,s.jsx)(e.div,{className:\"rehype-code-title\",children:\"await.js\"}),(0,s.jsx)(e.pre,{children:(0,s.jsxs)(e.code,{className:\"hljs language-JavaScript\",children:[(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"const\"}),\" someResult = \",(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"await\"}),\" \",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"someCall\"}),`();\n`,(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"const\"}),\" anotherResult = \",(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"await\"}),\" \",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"anotherCall\"}),`();\n`]})})]}),`\n`,(0,s.jsxs)(e.p,{children:[\"Here \",(0,s.jsx)(e.code,{children:\"anotherCall()\"}),\" will be called only when \",(0,s.jsx)(e.code,{children:\"someCall()\"}),\" is completed. What if you want to execute them in parallel?\"]}),`\n`,(0,s.jsx)(e.p,{children:\"Here's the simplest approach:\"}),`\n`,(0,s.jsxs)(l,{children:[(0,s.jsx)(e.div,{className:\"rehype-code-title\",children:\"parallel.js\"}),(0,s.jsx)(e.pre,{children:(0,s.jsxs)(e.code,{className:\"hljs language-JavaScript\",children:[(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"const\"}),\" [someResult, anotherResult] = \",(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"await\"}),\" \",(0,s.jsx)(e.span,{className:\"hljs-title class_\",children:\"Promise\"}),\".\",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"all\"}),\"([\",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"someCall\"}),\"(), \",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"anotherCall\"}),`()]);\n`]})})]}),`\n`,(0,s.jsxs)(e.p,{children:[\"Note that \",(0,s.jsx)(e.code,{children:\"Promise.all\"}),\" fails fast, which means that as soon as one of the promises supplied to it rejects, then the entire thing rejects. On the other hand, it will allow all the promises in it to run without blocking each other, but will prevent the execution to continue until ALL are resolved successfully.\"]}),`\n`,(0,s.jsx)(e.p,{children:\"For extra credit - here is a way to run many tasks in parallel and process the results individually as the tasks complete. I think it's pretty elegant.\"}),`\n`,(0,s.jsxs)(l,{children:[(0,s.jsx)(e.div,{className:\"rehype-code-title\",children:\"tasks.js\"}),(0,s.jsx)(e.pre,{children:(0,s.jsxs)(e.code,{className:\"hljs language-JavaScript\",children:[(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"function\"}),\" \",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"wait\"}),\"(\",(0,s.jsx)(e.span,{className:\"hljs-params\",children:\"ms, data\"}),`) {\n    `,(0,s.jsx)(e.span,{className:\"hljs-variable language_\",children:\"console\"}),\".\",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"log\"}),\"(\",(0,s.jsx)(e.span,{className:\"hljs-string\",children:\"'Starting task:'\"}),`, data, ms);\n    `,(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"return\"}),\" \",(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"new\"}),\" \",(0,s.jsx)(e.span,{className:\"hljs-title class_\",children:\"Promise\"}),\"(\",(0,s.jsxs)(e.span,{className:\"hljs-function\",children:[(0,s.jsx)(e.span,{className:\"hljs-params\",children:\"resolve\"}),\" =>\"]}),\" \",(0,s.jsx)(e.span,{className:\"hljs-built_in\",children:\"setTimeout\"}),`(resolve, ms, data));\n}\n\n`,(0,s.jsx)(e.span,{className:\"hljs-comment\",children:\"// run these in parallel, process results individually\"}),`\n`,(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"var\"}),` tasks = [\n    `,(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"async\"}),` () => {\n        `,(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"var\"}),\" result = \",(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"await\"}),\" \",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"wait\"}),\"(\",(0,s.jsx)(e.span,{className:\"hljs-number\",children:\"1000\"}),\", \",(0,s.jsx)(e.span,{className:\"hljs-string\",children:\"'burrito'\"}),`);\n        `,(0,s.jsx)(e.span,{className:\"hljs-comment\",children:\"// do something with result\"}),`\n        `,(0,s.jsx)(e.span,{className:\"hljs-variable language_\",children:\"console\"}),\".\",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"log\"}),`(result);\n    },\n    `,(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"async\"}),` () => {\n        `,(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"var\"}),\" result = \",(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"await\"}),\" \",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"wait\"}),\"(\",(0,s.jsx)(e.span,{className:\"hljs-number\",children:\"500\"}),\", \",(0,s.jsx)(e.span,{className:\"hljs-string\",children:\"'taco'\"}),`);\n        `,(0,s.jsx)(e.span,{className:\"hljs-comment\",children:\"// do something with result\"}),`\n        `,(0,s.jsx)(e.span,{className:\"hljs-variable language_\",children:\"console\"}),\".\",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"log\"}),`(result);\n    },\n    `,(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"async\"}),` () => {\n        `,(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"var\"}),\" result = \",(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"await\"}),\" \",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"wait\"}),\"(\",(0,s.jsx)(e.span,{className:\"hljs-number\",children:\"5000\"}),\", \",(0,s.jsx)(e.span,{className:\"hljs-string\",children:\"'tostada'\"}),`);\n        `,(0,s.jsx)(e.span,{className:\"hljs-comment\",children:\"// do something with result\"}),`\n        `,(0,s.jsx)(e.span,{className:\"hljs-variable language_\",children:\"console\"}),\".\",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"log\"}),`(result);\n    }\n]\n\n`,(0,s.jsx)(e.span,{className:\"hljs-keyword\",children:\"await\"}),\" \",(0,s.jsx)(e.span,{className:\"hljs-title class_\",children:\"Promise\"}),\".\",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"all\"}),\"(tasks.\",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"map\"}),\"(\",(0,s.jsxs)(e.span,{className:\"hljs-function\",children:[(0,s.jsx)(e.span,{className:\"hljs-params\",children:\"p\"}),\" =>\"]}),\" \",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"p\"}),`()));\n`,(0,s.jsx)(e.span,{className:\"hljs-variable language_\",children:\"console\"}),\".\",(0,s.jsx)(e.span,{className:\"hljs-title function_\",children:\"log\"}),\"(\",(0,s.jsx)(e.span,{className:\"hljs-string\",children:\"'done'\"}),`);\n`]})})]}),`\n`,(0,s.jsx)(e.p,{children:\"There results should look as follows:\"}),`\n`,(0,s.jsxs)(l,{children:[(0,s.jsx)(e.div,{className:\"rehype-code-title\",children:\"results.js\"}),(0,s.jsx)(e.pre,{children:(0,s.jsxs)(e.code,{className:\"hljs language-JavaScript\",children:[(0,s.jsx)(e.span,{className:\"hljs-title class_\",children:\"Starting\"}),\" \",(0,s.jsx)(e.span,{className:\"hljs-attr\",children:\"task\"}),\": burrito \",(0,s.jsx)(e.span,{className:\"hljs-number\",children:\"1000\"}),`\n`,(0,s.jsx)(e.span,{className:\"hljs-title class_\",children:\"Starting\"}),\" \",(0,s.jsx)(e.span,{className:\"hljs-attr\",children:\"task\"}),\": taco \",(0,s.jsx)(e.span,{className:\"hljs-number\",children:\"500\"}),`\n`,(0,s.jsx)(e.span,{className:\"hljs-title class_\",children:\"Starting\"}),\" \",(0,s.jsx)(e.span,{className:\"hljs-attr\",children:\"task\"}),\": tostada \",(0,s.jsx)(e.span,{className:\"hljs-number\",children:\"5000\"}),`\ntaco\nburrito\ntostada\ndone\n`]})})]}),`\n`,(0,s.jsx)(e.h2,{id:\"references\",children:\"References\"}),`\n`,(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:\"https://medium.com/velotio-perspectives/understanding-node-js-async-flows-parallel-serial-waterfall-and-queues-6f9c4badbc17\",children:\"Understanding Node.js Async Flows: Parallel, Serial, Waterfall and Queues\"})})]})}function _(a={}){let{wrapper:e}=a.components||{};return e?(0,s.jsx)(e,Object.assign({},a,{children:(0,s.jsx)(o,a)})):o(a)}var k=_;function v(a,e){throw new Error(\"Expected \"+(e?\"component\":\"object\")+\" `\"+a+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return f(b);})();\n;return Component;"
  },
  "_id": "snippets/parallel.mdx",
  "_raw": {
    "sourceFilePath": "snippets/parallel.mdx",
    "sourceFileName": "parallel.mdx",
    "sourceFileDir": "snippets",
    "contentType": "mdx",
    "flattenedPath": "snippets/parallel"
  },
  "type": "Snippet",
  "slug": "/snippets/parallel",
  "slugAsParams": "parallel",
  "stats": {
    "text": "2 min read",
    "minutes": 1.365,
    "time": 81900,
    "words": 273
  }
}