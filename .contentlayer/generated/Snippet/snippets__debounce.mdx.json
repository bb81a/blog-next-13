{
  "title": "Debounce",
  "summary": "Debouncing is a strategy that lets us improve performance by waiting until a certain amount of time has passed before triggering an event.",
  "icon": "js",
  "date": "2021-10-23T00:00:00.000Z",
  "published": true,
  "tags": [
    "Javascript"
  ],
  "body": {
    "raw": "\n<CodeBlock>\n\n```JavaScript:debounce.js\nconst debounce = (callback, wait) => {\n    let timeoutId = null;\n\n    return (...args) => {\n        window.clearTimeout(timeoutId);\n\n        timeoutId = window.setTimeout(() => {\n            callback.apply(null, args);\n        }, wait);\n    };\n\n};\n```\n\n</CodeBlock>\n\n### Context\n\nThere are many events in JS that trigger super quickly.\nWhen you scroll the page, or resize the window, or move your mouse, the browser captures dozens and dozens of events per second.\n\nIn many cases, you don't need to capture every single intermediate step; you're only interested in capturing the end state (when the user finishes scrolling, or finishes resizing the window).\nDebouncing is a strategy that lets us improve performance by waiting until a certain amount of time has passed before triggering an event. When the user stops triggering the event, our code will run.\n\nIn some cases, this isn't necessary. But, if any network requests are involved, or if the DOM changes (eg. re-rendering a component), this technique can drastically improve the smoothness of your application.\n\n#### Just use lodash?\n\n> For a long time, it was standard practice to include a utility library like Underscore or lodash. These libraries provide a bunch of handy general methods that fill in the gaps of the JavaScript standard library. They include a \\_.debounce function, that works just like the one shared above.\n>\n> As JS has gotten better and better over the years, these tools have become somewhat redundant. Aside from debouncing and throttling, pretty much everything else I'd want to do is now possible with vanilla JS!\n>\n> Now, you can install lodash and only use the debounce utility, but it'll make your bundle a bit heavier; the debounce utility weights ~2kb, even though the method is only a couple lines, because there's a minimum amount of \"utility glue\" that ships with all lodash utilities.\n>\n> 2kb isn't going to break your budget, but there's another benefit: you're reducing your reliance on third-party code. This debounce function is yours. It lives in your codebase, not in some node_modules folder, and you can modify it as-needed. Feel a sense of ownership over it. You won't have to worry about whether lodash will continue to be maintained.\n\n### Usage\n\n<CodeBlock>\n\n```JavaScript:debounceExample.js\nconst handleMouseMove = debounce((ev) => {\n  // Do stuff with the event!\n}, 250);\n\nwindow.addEventListener('mousemove', handleMouseMove);\n```\n\n</CodeBlock>\n\nIn this example, nothing will happen until the user starts moving the mouse, and then stops moving it for at least 250ms.\n\nNote that this example is focused on vanilla JS. If you're using React, you'll want to wrap your handler in useMemo, so that it doesn't get re-generated on every render. Here's an example that debounces the capturing of the mouse's X coordinate:\n\n<CodeBlock>\n\n```jsx:debounceExample.js\nfunction App() {\n    const [mouseX, setMouseX] = React.useState(null);\n\n    const handleMouseMove = React.useMemo(\n        debounce((ev) => {\n            setMouseX(ev.clientX);\n        }, 250),[]);\n\n    return (\n        <div onMouseMove={handleMouseMove}>\n            Mouse position: {mouseX}\n        </div>\n    );\n}\n```\n\n</CodeBlock>\n\nThis function isn't super easy to digest, especially if you're not used to functional programming! It's 100% OK to use this function without understanding it, but if you're curious, let's pop the hood and see if we can sort it out.\n\nHere's the code again:\n\n<CodeBlock>\n\n```jsx:debounceExample.js\nconst debounce = (callback, wait) => {\n    let timeoutId = null;\n\n    return (...args) => {\n        window.clearTimeout(timeoutId);\n\n        timeoutId = window.setTimeout(() => {\n            callback.apply(null, args);\n        }, wait);\n    };\n}\n```\n\n</CodeBlock>\n\nOur debounce function takes two arguments: a callback function and a duration in milliseconds.\nWe want the debounce function to itself return a function. Functions returning functions always hurts my brain, but it helps when we think about the practical aspects of how it's used:\n\n<CodeBlock>\n\n```jsx:debounceExample.js\nconst debouncedFunction = debounce(function() { ... }, 250)\n\nconsole.log(typeof debouncedFunction); // `function`\n```\n\n</CodeBlock>\n\nHere's how I like to think about it:\n\nYour initial function, the stuff you're actually trying to do, is a piece of hard candy.The debounce function is a piece of factory machinery that wraps that candy in a shiny plastic wrapperThe function that gets returned is your wrapped piece of candy. We've augmented that piece of candy with a wrapper.\n\nNotice that the first line in that function initializes a variable, \"timeoutId\". This line is only executed once. We plan to call our wrapped function many times, but we only call debounce() at the beginning.\n\nWhenever the wrapped function is triggered, two things happen:\n\n1. We cancel any pre-existing timeout\n2. We schedule a new timeout, based on the amount of time indicated by the wait argument. When the timeout expires, we call our callback function with apply, and feed it whatever arguments we have.\n\nThe very first time the user moves the mouse, that first step has no effect; nothing has been scheduled yet! Happily, window.clearTimeout is a very forgiving function; even if there is no timeout, it doesn't complain. It's a “no-op” — it does nothing.\n\nsetTimeout returns a number, a reference to the specific timeout in question. We store that in our timeoutId variable. Because this variable is held outside our wrapped function's scope, it persists.\n\nLet's say the user hasn't finished moving the mouse. A few milliseconds pass, and our wrapper is called again. This time around, timeoutId points to a currently-scheduled timeout, so the first line cancels it. And then we schedule a new one.\n\nIf the user moves the mouse for 1 second, this cycle will repeat dozens of times. Lots of scheduled-and-immediately-cancelled timeouts. But once they stop moving, the cycle stops. The moment 250ms elapses, our timeout fires back, and the code is ultimately run.\n\nThis is a complex sequence! But it works like a charm. Scheduling and cleaning up timeouts is a very quick, low-memory operation, so we don't have to worry much about its cost.\n",
    "code": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(s,e)=>()=>(e||s((e={exports:{}}).exports,e),e.exports),y=(s,e)=>{for(var a in e)i(s,a,{get:e[a],enumerable:!0})},c=(s,e,a,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of p(e))!g.call(s,t)&&t!==a&&i(s,t,{get:()=>e[t],enumerable:!(l=u(e,t))||l.enumerable});return s};var b=(s,e,a)=>(a=s!=null?d(m(s)):{},c(e||!s||!s.__esModule?i(a,\"default\",{value:s,enumerable:!0}):a,s)),j=s=>c(i({},\"__esModule\",{value:!0}),s);var r=f((M,o)=>{o.exports=_jsx_runtime});var _={};y(_,{default:()=>v,frontmatter:()=>w});var n=b(r()),w={title:\"Debounce\",published:!0,date:\"2021-10-23\",summary:\"Debouncing is a strategy that lets us improve performance by waiting until a certain amount of time has passed before triggering an event.\",icon:\"js\",tags:[\"Javascript\"]};function h(s){let e=Object.assign({div:\"div\",pre:\"pre\",code:\"code\",span:\"span\",h3:\"h3\",p:\"p\",h4:\"h4\",blockquote:\"blockquote\",ol:\"ol\",li:\"li\"},s.components),{CodeBlock:a}=e;return a||k(\"CodeBlock\",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(a,{children:[(0,n.jsx)(e.div,{className:\"rehype-code-title\",children:\"debounce.js\"}),(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-JavaScript\",children:[(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-title function_\",children:\"debounce\"}),\" = (\",(0,n.jsx)(e.span,{className:\"hljs-params\",children:\"callback, wait\"}),`) => {\n    `,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"let\"}),\" timeoutId = \",(0,n.jsx)(e.span,{className:\"hljs-literal\",children:\"null\"}),`;\n\n    `,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"return\"}),\" \",(0,n.jsxs)(e.span,{className:\"hljs-function\",children:[\"(\",(0,n.jsx)(e.span,{className:\"hljs-params\",children:\"...args\"}),\") =>\"]}),` {\n        `,(0,n.jsx)(e.span,{className:\"hljs-variable language_\",children:\"window\"}),\".\",(0,n.jsx)(e.span,{className:\"hljs-built_in\",children:\"clearTimeout\"}),`(timeoutId);\n\n        timeoutId = `,(0,n.jsx)(e.span,{className:\"hljs-variable language_\",children:\"window\"}),\".\",(0,n.jsx)(e.span,{className:\"hljs-built_in\",children:\"setTimeout\"}),\"(\",(0,n.jsx)(e.span,{className:\"hljs-function\",children:\"() =>\"}),` {\n            callback.`,(0,n.jsx)(e.span,{className:\"hljs-title function_\",children:\"apply\"}),\"(\",(0,n.jsx)(e.span,{className:\"hljs-literal\",children:\"null\"}),`, args);\n        }, wait);\n    };\n\n};\n`]})})]}),`\n`,(0,n.jsx)(e.h3,{id:\"context\",children:\"Context\"}),`\n`,(0,n.jsx)(e.p,{children:`There are many events in JS that trigger super quickly.\nWhen you scroll the page, or resize the window, or move your mouse, the browser captures dozens and dozens of events per second.`}),`\n`,(0,n.jsx)(e.p,{children:`In many cases, you don't need to capture every single intermediate step; you're only interested in capturing the end state (when the user finishes scrolling, or finishes resizing the window).\nDebouncing is a strategy that lets us improve performance by waiting until a certain amount of time has passed before triggering an event. When the user stops triggering the event, our code will run.`}),`\n`,(0,n.jsx)(e.p,{children:\"In some cases, this isn't necessary. But, if any network requests are involved, or if the DOM changes (eg. re-rendering a component), this technique can drastically improve the smoothness of your application.\"}),`\n`,(0,n.jsx)(e.h4,{id:\"just-use-lodash\",children:\"Just use lodash?\"}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"For a long time, it was standard practice to include a utility library like Underscore or lodash. These libraries provide a bunch of handy general methods that fill in the gaps of the JavaScript standard library. They include a _.debounce function, that works just like the one shared above.\"}),`\n`,(0,n.jsx)(e.p,{children:\"As JS has gotten better and better over the years, these tools have become somewhat redundant. Aside from debouncing and throttling, pretty much everything else I'd want to do is now possible with vanilla JS!\"}),`\n`,(0,n.jsx)(e.p,{children:`Now, you can install lodash and only use the debounce utility, but it'll make your bundle a bit heavier; the debounce utility weights ~2kb, even though the method is only a couple lines, because there's a minimum amount of \"utility glue\" that ships with all lodash utilities.`}),`\n`,(0,n.jsx)(e.p,{children:\"2kb isn't going to break your budget, but there's another benefit: you're reducing your reliance on third-party code. This debounce function is yours. It lives in your codebase, not in some node_modules folder, and you can modify it as-needed. Feel a sense of ownership over it. You won't have to worry about whether lodash will continue to be maintained.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{id:\"usage\",children:\"Usage\"}),`\n`,(0,n.jsxs)(a,{children:[(0,n.jsx)(e.div,{className:\"rehype-code-title\",children:\"debounceExample.js\"}),(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-JavaScript\",children:[(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"const\"}),\" handleMouseMove = \",(0,n.jsx)(e.span,{className:\"hljs-title function_\",children:\"debounce\"}),\"(\",(0,n.jsxs)(e.span,{className:\"hljs-function\",children:[\"(\",(0,n.jsx)(e.span,{className:\"hljs-params\",children:\"ev\"}),\") =>\"]}),` {\n  `,(0,n.jsx)(e.span,{className:\"hljs-comment\",children:\"// Do stuff with the event!\"}),`\n}, `,(0,n.jsx)(e.span,{className:\"hljs-number\",children:\"250\"}),`);\n\n`,(0,n.jsx)(e.span,{className:\"hljs-variable language_\",children:\"window\"}),\".\",(0,n.jsx)(e.span,{className:\"hljs-title function_\",children:\"addEventListener\"}),\"(\",(0,n.jsx)(e.span,{className:\"hljs-string\",children:\"'mousemove'\"}),`, handleMouseMove);\n`]})})]}),`\n`,(0,n.jsx)(e.p,{children:\"In this example, nothing will happen until the user starts moving the mouse, and then stops moving it for at least 250ms.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Note that this example is focused on vanilla JS. If you're using React, you'll want to wrap your handler in useMemo, so that it doesn't get re-generated on every render. Here's an example that debounces the capturing of the mouse's X coordinate:\"}),`\n`,(0,n.jsxs)(a,{children:[(0,n.jsx)(e.div,{className:\"rehype-code-title\",children:\"debounceExample.js\"}),(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-jsx\",children:[(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"function\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-title function_\",children:\"App\"}),\"(\",(0,n.jsx)(e.span,{className:\"hljs-params\"}),`) {\n    `,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"const\"}),\" [mouseX, setMouseX] = \",(0,n.jsx)(e.span,{className:\"hljs-title class_\",children:\"React\"}),\".\",(0,n.jsx)(e.span,{className:\"hljs-title function_\",children:\"useState\"}),\"(\",(0,n.jsx)(e.span,{className:\"hljs-literal\",children:\"null\"}),`);\n\n    `,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"const\"}),\" handleMouseMove = \",(0,n.jsx)(e.span,{className:\"hljs-title class_\",children:\"React\"}),\".\",(0,n.jsx)(e.span,{className:\"hljs-title function_\",children:\"useMemo\"}),`(\n        `,(0,n.jsx)(e.span,{className:\"hljs-title function_\",children:\"debounce\"}),\"(\",(0,n.jsxs)(e.span,{className:\"hljs-function\",children:[\"(\",(0,n.jsx)(e.span,{className:\"hljs-params\",children:\"ev\"}),\") =>\"]}),` {\n            `,(0,n.jsx)(e.span,{className:\"hljs-title function_\",children:\"setMouseX\"}),\"(ev.\",(0,n.jsx)(e.span,{className:\"hljs-property\",children:\"clientX\"}),`);\n        }, `,(0,n.jsx)(e.span,{className:\"hljs-number\",children:\"250\"}),`),[]);\n\n    `,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"return\"}),` (\n        `,(0,n.jsxs)(e.span,{className:\"xml\",children:[(0,n.jsxs)(e.span,{className:\"hljs-tag\",children:[\"<\",(0,n.jsx)(e.span,{className:\"hljs-name\",children:\"div\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-attr\",children:\"onMouseMove\"}),\"=\",(0,n.jsx)(e.span,{className:\"hljs-string\",children:\"{handleMouseMove}\"}),\">\"]}),`\n            Mouse position: {mouseX}\n        `,(0,n.jsxs)(e.span,{className:\"hljs-tag\",children:[\"</\",(0,n.jsx)(e.span,{className:\"hljs-name\",children:\"div\"}),\">\"]})]}),`\n    );\n}\n`]})})]}),`\n`,(0,n.jsx)(e.p,{children:\"This function isn't super easy to digest, especially if you're not used to functional programming! It's 100% OK to use this function without understanding it, but if you're curious, let's pop the hood and see if we can sort it out.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Here's the code again:\"}),`\n`,(0,n.jsxs)(a,{children:[(0,n.jsx)(e.div,{className:\"rehype-code-title\",children:\"debounceExample.js\"}),(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-jsx\",children:[(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"const\"}),\" \",(0,n.jsx)(e.span,{className:\"hljs-title function_\",children:\"debounce\"}),\" = (\",(0,n.jsx)(e.span,{className:\"hljs-params\",children:\"callback, wait\"}),`) => {\n    `,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"let\"}),\" timeoutId = \",(0,n.jsx)(e.span,{className:\"hljs-literal\",children:\"null\"}),`;\n\n    `,(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"return\"}),\" \",(0,n.jsxs)(e.span,{className:\"hljs-function\",children:[\"(\",(0,n.jsx)(e.span,{className:\"hljs-params\",children:\"...args\"}),\") =>\"]}),` {\n        `,(0,n.jsx)(e.span,{className:\"hljs-variable language_\",children:\"window\"}),\".\",(0,n.jsx)(e.span,{className:\"hljs-built_in\",children:\"clearTimeout\"}),`(timeoutId);\n\n        timeoutId = `,(0,n.jsx)(e.span,{className:\"hljs-variable language_\",children:\"window\"}),\".\",(0,n.jsx)(e.span,{className:\"hljs-built_in\",children:\"setTimeout\"}),\"(\",(0,n.jsx)(e.span,{className:\"hljs-function\",children:\"() =>\"}),` {\n            callback.`,(0,n.jsx)(e.span,{className:\"hljs-title function_\",children:\"apply\"}),\"(\",(0,n.jsx)(e.span,{className:\"hljs-literal\",children:\"null\"}),`, args);\n        }, wait);\n    };\n}\n`]})})]}),`\n`,(0,n.jsx)(e.p,{children:`Our debounce function takes two arguments: a callback function and a duration in milliseconds.\nWe want the debounce function to itself return a function. Functions returning functions always hurts my brain, but it helps when we think about the practical aspects of how it's used:`}),`\n`,(0,n.jsxs)(a,{children:[(0,n.jsx)(e.div,{className:\"rehype-code-title\",children:\"debounceExample.js\"}),(0,n.jsx)(e.pre,{children:(0,n.jsxs)(e.code,{className:\"hljs language-jsx\",children:[(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"const\"}),\" debouncedFunction = \",(0,n.jsx)(e.span,{className:\"hljs-title function_\",children:\"debounce\"}),\"(\",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"function\"}),\"(\",(0,n.jsx)(e.span,{className:\"hljs-params\"}),\") { ... }, \",(0,n.jsx)(e.span,{className:\"hljs-number\",children:\"250\"}),`)\n\n`,(0,n.jsx)(e.span,{className:\"hljs-variable language_\",children:\"console\"}),\".\",(0,n.jsx)(e.span,{className:\"hljs-title function_\",children:\"log\"}),\"(\",(0,n.jsx)(e.span,{className:\"hljs-keyword\",children:\"typeof\"}),\" debouncedFunction); \",(0,n.jsx)(e.span,{className:\"hljs-comment\",children:\"// `function`\"}),`\n`]})})]}),`\n`,(0,n.jsx)(e.p,{children:\"Here's how I like to think about it:\"}),`\n`,(0,n.jsx)(e.p,{children:\"Your initial function, the stuff you're actually trying to do, is a piece of hard candy.The debounce function is a piece of factory machinery that wraps that candy in a shiny plastic wrapperThe function that gets returned is your wrapped piece of candy. We've augmented that piece of candy with a wrapper.\"}),`\n`,(0,n.jsx)(e.p,{children:'Notice that the first line in that function initializes a variable, \"timeoutId\". This line is only executed once. We plan to call our wrapped function many times, but we only call debounce() at the beginning.'}),`\n`,(0,n.jsx)(e.p,{children:\"Whenever the wrapped function is triggered, two things happen:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"We cancel any pre-existing timeout\"}),`\n`,(0,n.jsx)(e.li,{children:\"We schedule a new timeout, based on the amount of time indicated by the wait argument. When the timeout expires, we call our callback function with apply, and feed it whatever arguments we have.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The very first time the user moves the mouse, that first step has no effect; nothing has been scheduled yet! Happily, window.clearTimeout is a very forgiving function; even if there is no timeout, it doesn't complain. It's a \\u201Cno-op\\u201D \\u2014 it does nothing.\"}),`\n`,(0,n.jsx)(e.p,{children:\"setTimeout returns a number, a reference to the specific timeout in question. We store that in our timeoutId variable. Because this variable is held outside our wrapped function's scope, it persists.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Let's say the user hasn't finished moving the mouse. A few milliseconds pass, and our wrapper is called again. This time around, timeoutId points to a currently-scheduled timeout, so the first line cancels it. And then we schedule a new one.\"}),`\n`,(0,n.jsx)(e.p,{children:\"If the user moves the mouse for 1 second, this cycle will repeat dozens of times. Lots of scheduled-and-immediately-cancelled timeouts. But once they stop moving, the cycle stops. The moment 250ms elapses, our timeout fires back, and the code is ultimately run.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This is a complex sequence! But it works like a charm. Scheduling and cleaning up timeouts is a very quick, low-memory operation, so we don't have to worry much about its cost.\"})]})}function N(s={}){let{wrapper:e}=s.components||{};return e?(0,n.jsx)(e,Object.assign({},s,{children:(0,n.jsx)(h,s)})):h(s)}var v=N;function k(s,e){throw new Error(\"Expected \"+(e?\"component\":\"object\")+\" `\"+s+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return j(_);})();\n;return Component;"
  },
  "_id": "snippets/debounce.mdx",
  "_raw": {
    "sourceFilePath": "snippets/debounce.mdx",
    "sourceFileName": "debounce.mdx",
    "sourceFileDir": "snippets",
    "contentType": "mdx",
    "flattenedPath": "snippets/debounce"
  },
  "type": "Snippet",
  "slug": "/snippets/debounce",
  "slugAsParams": "debounce",
  "stats": {
    "text": "5 min read",
    "minutes": 4.76,
    "time": 285600,
    "words": 952
  }
}